<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://zhix.co/</link><description>zhix 的精神避难所。</description><generator>Hugo 0.86.0 https://gohugo.io/</generator><language>zh-CN</language><managingEditor>zhixuan@zhix.co (zhix)</managingEditor><webMaster>zhixuan@zhix.co (zhix)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><lastBuildDate>Sun, 01 Aug 2021 12:00:08 +0800</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://zhix.co/rss.xml"/><item><title>在 Buddy 上持续部署 Hugo</title><link>https://zhix.co/posts/setup-continuous-build-to-hugo-with-buddy/</link><guid isPermaLink="true">https://zhix.co/posts/setup-continuous-build-to-hugo-with-buddy/</guid><pubDate>Sun, 12 Apr 2020 15:52:13 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>写博客的已经一个月了，我也逐渐适应了平日收集灵感，周末码字的习惯，Hugo 作为 SSG 工具，本身的构建过程足够快速和简单，但随着博客配置的不断完善，自动化部署和发布的需求逐渐提上了日程。&lt;/p>
&lt;h2 id="持续构建">持续构建&lt;/h2>
&lt;p>构建（Build）的概念来源于软件工程，指的是源码提交到代码仓库之后的编译、测试、安装、部署等步骤，通常 Web 应用程序的构建可能包含以下过程：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>源码编译&lt;/strong>：编译是最基础的构建，编译器需要知道从何处引入依赖库并按照特定的编译参数编译源码，例如 TypeScript、SCSS 编写的代码需要编译成浏览器可运行的 JavaScript 和 CSS；&lt;/li>
&lt;li>&lt;strong>资源处理&lt;/strong>：静态资源文件比如 JavaScript 和 CSS 的压缩；&lt;/li>
&lt;li>&lt;strong>代码混淆&lt;/strong>：变量名的混淆处理，常见与前端与移动应用；&lt;/li>
&lt;li>&lt;strong>签名&lt;/strong>：计算构件输出文件的摘要并用开发者的证书签名，常见于移动应用；&lt;/li>
&lt;li>&lt;strong>容器化部署&lt;/strong>：创建 Docker 映像并在容器环境下启动应用；&lt;/li>
&lt;/ul>
&lt;p>这些步骤非常繁琐，因环境的不同而需要不同的配置参数，尤其是编译需要极高的计算力资源，人为地一一操作容易出错且影响效率，所以持续构建的概念应运而生。&lt;/p>
&lt;p>持续指的是通过技术的手段让对应的过程尽可能迅速而自动化的完成，将整个迭代流程推向下一阶段，并且尽早地暴露问题，与此相关的概念还有持续集成、持续部署。&lt;/p>
&lt;h2 id="部署的石器时代">部署的石器时代&lt;/h2>
&lt;p>在使用持续部署前，我的博客怎么做上线呢？当我写完了新的文章，或者对错别字和样式做修复后，我会在自己机器上运行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">hugo --gc
&lt;/code>&lt;/pre>&lt;/div>&lt;p>命令会有如下的输出，表示生成了多少个 &lt;kbd>⌘&lt;/kbd> + &lt;kbd>⌥&lt;/kbd> + &lt;kbd>⇧&lt;/kbd> + &lt;kbd>⇪&lt;/kbd> 静态页面：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200425120527.jpg" alt="">&lt;/p>
&lt;p>然后提交到版本控制系统，如果这个修改是主题范围内的，还要修改主题的仓库。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200425122401.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200413005729.jpg#border" alt="写博客时的界面，左边预览右边编写" title="写博客时的界面，左边预览右边编写">&lt;/p>
&lt;p>每次的修订和发布涉及到 3 个 Git 仓库的联动：&lt;/p>
&lt;dl>
&lt;dt>博客源仓库&lt;/dt>
&lt;dd>Hugo 生成的源站，包含 Hugo 配置文件、所有文章的 Markdown 源文件、静态资源、CNAME 文件等。&lt;/dd>
&lt;dt>博客主题仓库&lt;/dt>
&lt;dd>作为源仓库的 submodule，主题作为一个单独的仓库，因为我需要同时跟踪自定义修改和主题作者的迭代。&lt;/dd>
&lt;dt>构建后的静态站点仓库&lt;/dt>
&lt;dd>基于源站由 &lt;code>hugo&lt;/code> 命令构建生成，是最终发布的构件。&lt;/dd>
&lt;/dl>
&lt;p>每次的发布的步骤为：&lt;/p>
&lt;ol>
&lt;li>如果主题仓库有变动，比如修改了主题样式，提交并推送至 GitHub；&lt;/li>
&lt;li>如果源仓库有变动，比如新增了文章，提交并推送至 GitHub；&lt;/li>
&lt;li>在博客源仓库根目录运行命令 &lt;code>hugo --gc&lt;/code> 生成最新的静态站点至 &lt;code>public&lt;/code> 文件夹；&lt;/li>
&lt;li>由于博客使用了 Service Worker，需要重新使用 Gulp 生成 &lt;code>sw.js&lt;/code> 文件；&lt;/li>
&lt;li>将构建后的静态站点推送至 GitHub，打好日期标签；&lt;/li>
&lt;li>推送完成后 GitHub Pages 的内容会发生变化，由于博客使用了 CloudFlare 的页面缓存功能，我需要登录 CloudFlare 操作清理 CDN 缓存。&lt;/li>
&lt;/ol>
&lt;p>一通操作都完成Hugo又没有&lt;code>hexo d&lt;/code>这样的一键部署后才算发布成功，虽然 Hugo 本身的构建非常迅速，但是考虑到推送远程仓库和后续 CloudFlare 的操作，稍微修改地频繁一点就显得有点繁琐了，这时候持续构建的必要性就体现出来了。&lt;/p>
&lt;h2 id="持续部署-hugo-的解决方案">持续部署 Hugo 的解决方案&lt;/h2>
&lt;p>一般对 Hugo 的持续部署有以下几种选择：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">名称&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="">Travis CI&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="">Netlify&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="">GitLab CI&lt;/a>&lt;/td>
&lt;td style="text-align:left">持续集成平台&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://buddy.works">Buddy&lt;/a>&lt;/td>
&lt;td style="text-align:left">持续集成平台&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="https://buddy.works">Buddy Works&lt;/a> 是一款简单好用的 CI 平台，用户界面比较友好，免费计划足够个人部署博客使用。&lt;/p>
&lt;h3 id="travis-ci-和-gitlab-ci-的尝试">Travis CI 和 GitLab CI 的尝试&lt;/h3>
&lt;h2 id="基于-buddy-做持续构建">基于 Buddy 做持续构建&lt;/h2>
&lt;p>首先确定构建的步骤，假设构建的机器上只有一个新安装的 Linux 发行版，每次发布的流程可以概括为：&lt;/p>
&lt;ol>
&lt;li>在构建机器上安装 Git、Hugo 和 Node 的发行版，以便拉取代码、生成博客页面和更新 Service Worker&lt;sup id="fnref:1">&lt;a href="https://zhix.co/posts/setup-continuous-build-to-hugo-with-buddy/#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>；&lt;/li>
&lt;li>从「博客源仓库」同步最新代码；&lt;/li>
&lt;li>从「博客主题仓库」同步最新代码，主题仓库作为源仓库的 &lt;span lang="en">submodule&lt;/span> 更新，如果 &lt;span lang="en">submodule&lt;/span> 是私有仓库，确保构建机器具有访问仓库的权限（配置 &lt;span lang="en">Access Token&lt;/span> 或者 SSH Key）；&lt;/li>
&lt;li>让 Hugo 生成最新的博客页面；&lt;/li>
&lt;li>调用 NPM 安装 Gulp 和 Service Worker 的依赖；&lt;/li>
&lt;li>通过 Gulp 生成新的 Service Worker 脚本；&lt;/li>
&lt;li>推送所有生成的内容至「博客静态站点仓库」；&lt;/li>
&lt;li>通过 API 调用 CloudFlare 清除 CDN 缓存；&lt;/li>
&lt;/ol>
&lt;p>用流程图表示为：&lt;/p>
&lt;div class="mermaid">
graph TD;
BS[/构建开始/]
BE[/构建结束/]
ID([依赖安装完成])
SS([源码同步])
HS([博客静态站点生成])
GPS([GitHub Pages 同步])
CS([CDN 同步])
BS --> |在目标机器上安装依赖| ID
ID --> |拉取博客和主题源码| SS
SS --> |Hugo 生成站点 &amp; Gulp 生成 sw.js| HS
HS --> |推送内容至 GitHub Pages| GPS
GPS --> |CloudFlare 清除 CDN 缓存| CS
CS --> BE
&lt;/div>
&lt;h3 id="工作空间配置">工作空间配置&lt;/h3>
&lt;p>用你自己的方式注册和登录 Buddy，并授权 Buddy 访问你的 GitHub 仓库，&lt;/p>
&lt;h3 id="创建-docker-映像">创建 Docker 映像&lt;/h3>
&lt;p>这一步主要是撰写 Dockerfile&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> alpine:3.11&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># Hugo 版本&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ARG&lt;/span> &lt;span class="nv">HUGO_VERSION&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">0&lt;/span>.69.0&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ARG&lt;/span> &lt;span class="nv">HUGO_TYPE&lt;/span>&lt;span class="o">=&lt;/span>_extended
&lt;span class="k">ARG&lt;/span> &lt;span class="nv">HUGO_URL&lt;/span>&lt;span class="o">=&lt;/span>https://github.com/gohugoio/hugo/releases/download/v&lt;span class="si">${&lt;/span>&lt;span class="nv">HUGO_VERSION&lt;/span>&lt;span class="si">}&lt;/span>/hugo&lt;span class="si">${&lt;/span>&lt;span class="nv">HUGO_TYPE&lt;/span>&lt;span class="si">}&lt;/span>_&lt;span class="si">${&lt;/span>&lt;span class="nv">HUGO_VERSION&lt;/span>&lt;span class="si">}&lt;/span>_Linux-64bit.tar.gz&lt;span class="err">
&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="c"># 安装必要依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apk upgrade &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> apk add --update wget libc6-compat libstdc++ nodejs npm git openssh &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> wget -O hugo.tar.gz &lt;span class="si">${&lt;/span>&lt;span class="nv">HUGO_URL&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> tar xvf hugo.tar.gz &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> mv hugo /usr/bin &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> rm hugo.tar.gz &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> npm install workbox-build gulp gulp-uglify readable-stream uglify-es --global &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> hugo version&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="生成博客页面">生成博客页面&lt;/h3>
&lt;h3 id="更新-service-worker">更新 Service Worker&lt;/h3>
&lt;h3 id="清理缓存可选">清理缓存（可选）&lt;/h3>
&lt;h2 id="总结">总结&lt;/h2>
&lt;h2 id="延伸阅读">延伸阅读&lt;/h2>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Service Worker 的构建步骤是可选的，如果你的站点不是一个 &lt;a href="">PWA&lt;/a> 程序的话。&amp;#160;&lt;a href="https://zhix.co/posts/setup-continuous-build-to-hugo-with-buddy/#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/series/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</category><category domain="https://zhix.co/tags/hugo/">hugo</category><category domain="https://zhix.co/tags/buddy/">buddy</category><category domain="https://zhix.co/tags/docker/">docker</category><category domain="https://zhix.co/tags/cloudflare/">cloudflare</category><category domain="https://zhix.co/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/">持续部署</category><category domain="https://zhix.co/tags/%E5%8D%9A%E5%AE%A2/">博客</category></item><item><title>谈谈技术博客的排版</title><link>https://zhix.co/posts/talking-typesetting/</link><guid isPermaLink="true">https://zhix.co/posts/talking-typesetting/</guid><pubDate>Tue, 31 Mar 2020 22:01:33 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>相比于国内已有的内容平台，比如豆瓣、知乎、公众号，独立博客在搭建、配置和维护上会花费额外的精力，也需要一定动手能力才能持续运作，但是相对地，独立博客能更加灵活地控制内容产出，更加自由地挥洒笔墨，对排版样式更可以进行像素级的控制。&lt;/p>
&lt;p>排版简单来说就是考虑如何组织文本，让文章对读者更加友好 &amp;mdash; 这涉及到字体、字型、段落等元素的样式平衡。排版定义了网站的整体基调，引导读者阅读，决定用户体验，正如 &lt;a href="https://github.com/sparanoid/chinese-copywriting-guidelines/">中文文案排版指北&lt;/a> 所说，一致的排版能够降低团队成员之间的沟通成本，增强网站气质，整齐划一的排版也是我写博客所追求的目标。&lt;/p>
&lt;p>接下来我想谈谈博客在样式上的配置，包括相关 CSS 特性的讨论，以及我对技术博客排版的个人理解。文章组成博客，段落组成文章，段落的排版决定了博客的排版，段落的排版又以字体、行距、对齐最为关键。&lt;/p>
&lt;h2 id="两端对齐">两端对齐&lt;/h2>
&lt;p>正文段落 &lt;a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E9%BD%8A#%E4%B8%A4%E7%AB%AF%E5%B0%8D%E9%BD%8A/">两端对齐&lt;/a>（&lt;em>&lt;span lang="en">justify&lt;/span>&lt;/em>），与 Web 中常规的 &lt;a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E9%BD%8A#%E9%9D%A0%E5%B7%A6%E5%B0%8D%E9%BD%8A/">左对齐&lt;/a>（&lt;em>&lt;span lang="en">Left justify&lt;/span>&lt;/em>）相比，两端对齐保持各行左右边距的基线一致，视觉上更加整齐，适合中文这样单个字符构成的语言。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200405182842.png#border" alt="两端对齐（上）与左对齐（下）的效果对比" title="两端对齐（上）与左对齐（下）的效果对比">&lt;/p>
&lt;p>左对齐时，字符之间的间隙均等，行尾超过容器宽度的长单词折行显示；两端对齐时，字符之间的间隙不等，行尾的长单词同样会折行，但是会相应调整上一行的字符间隙来填充空白。&lt;/p>
&lt;p>在 Web 中实现两端对齐，完整且保证兼容性的 CSS 写法为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">text-align&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">justify&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/* 文本两端对齐 */&lt;/span>
&lt;span class="k">text-justify&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">inter-ideograph&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/* 调整表意文字间距以保持两端对齐 */&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>text-align: justify&lt;/code> 对应文本两端对齐，&lt;code>text-justify&lt;/code> 表示在保持两端对齐的情况下如何处理间距，中文段落一般选择 &lt;code>inter-ideograph&lt;/code>，它表示调整 CJK 表意文字字符和单词的间距来适应布局，也可以用 &lt;code>distribute&lt;/code> 代替：&lt;/p>
&lt;p>不过主流浏览器对 &lt;code>text-justify&lt;/code> 的支持不佳，截至本文完成，只有 Firefox 有 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-justify/">较好的支持&lt;/a>。&lt;/p>
&lt;p>除了段落 &amp;lt;p&amp;gt; 之外，以下可能存在折行内容的标签也建议使用两端对齐：&lt;/p>
&lt;ul>
&lt;li>列表项（&lt;em>&amp;lt;li&amp;gt;&lt;/em>）&lt;/li>
&lt;li>定义列表项（&lt;em>&amp;lt;dd&amp;gt;&lt;/em>）&lt;/li>
&lt;/ul>
&lt;h3 id="两端对齐的不足">两端对齐的不足&lt;/h3>
&lt;p>两端对齐的不足主要在于中西文混排时的行间疏密参差不齐，这一点在移动设备上更为明显，下图中的单词 &lt;em>RedisCache&lt;/em> 显得过于松散，是因为浏览器为了保持对齐而做了字符间距补偿：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200406002400.png#mobile-screenshot" alt="width-360" title="iPhone 8 上的显示效果">&lt;/p>
&lt;p>目前这种情况没有一劳永逸的解决方案，只能等未来 CSS 标准和浏览器实现能支持更加智能的折行，临时方案要么使用左对齐，要么尽量在文本中少用西文单词。&lt;/p>
&lt;h3 id="折行">折行&lt;/h3>
&lt;p>提到对齐方式不得不说折行，折行规定了文本过长时容器的处理方式。不同语言的书写系统对折行有不同要求，东亚语言（中文、日文、韩文等）用「音节」而不是「空格」区分单词，这些语言的文本几乎可以在任何字符之间折行&lt;sup id="fnref:1">&lt;a href="https://zhix.co/posts/talking-typesetting/#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。建议的配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">line-break&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">word-break&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">break-word&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">overflow-wrap&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">break-word&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>word-break&lt;/code> 控制断字符，&lt;code>overflow-wrap&lt;/code> 控制断词，这几个 CSS 属性很容易混淆，上述的配置已经适用于大部分中英混排的场景。&lt;/p>
&lt;h2 id="段落">段落&lt;/h2>
&lt;p>内容按段落划分，段落标题应当从 &lt;em>&amp;lt;h2&amp;gt;&lt;/em> 开始，为什么不是 &lt;em>&amp;lt;h1&amp;gt;&lt;/em> 呢？因为 &lt;em>&amp;lt;h1&amp;gt;&lt;/em> 一般作为网页标题而特殊存在，一个页面建议只有一个 &lt;em>&amp;lt;h1&amp;gt;&lt;/em> 标签，即 &lt;em>&amp;lt;h1&amp;gt;&lt;/em> 是单例的。&lt;/p>
&lt;blockquote>
&lt;p>当被加载到浏览器中的时候，元素 &lt;em>&amp;lt;h1&amp;gt;&lt;/em> 会出现在页面中 —— 通常它应该在一个页面中只被使用一次，它被用来标记你的页面内容的标题（故事的标题，新闻标题或者任何适当的方式）。&lt;/p>
&lt;footer>
—— &lt;cite>MDN·HTML 介绍&lt;/cite>
&lt;/footer>
&lt;/blockquote>
&lt;p>行高一般设置在 1.5~2 之间即可，本博客是 1.75，用 CSS 表示为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="nt">p&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">line-height&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">1.75&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="西文段落">西文段落&lt;/h3>
&lt;p>纯西文段落更加适合左对齐，应当在 CSS 用伪选择器为其单独设置语言属性。举例来说，假设 HTML 文档的语言为中文，即 &lt;code>&amp;lt;html lang=&amp;quot;zh&amp;quot;&amp;gt;&lt;/code> 时，有段落如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>朝辞白帝彩云间，千里江陵一日还。&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">p&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时标签 &lt;em>&amp;lt;p&amp;gt;&lt;/em> 没有显式设置 &lt;em>&amp;lt;lang&amp;gt;&lt;/em> 属性，将使用当前 HTML 的语言属性 &lt;em>zh&lt;/em>，而对西文段落，例如：&lt;/p>
&lt;p>Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.&lt;/p>
&lt;p>为了追求更好的排版效果，我们添加 &lt;em>lang=&amp;ldquo;en&amp;rdquo;&lt;/em> 属性，并单独设置行高的对齐：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="nt">p&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nd">lang&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nt">en&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">line-height&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mf">1.5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/* 西文字母较小，行距从 1.75 减小至 1.5 */&lt;/span>
&lt;span class="k">text-align&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">left&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/* 西文文本左对齐 */&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>此外，可以进一步设置基于浏览器词典的自动断词：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="nt">p&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nd">lang&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nt">en&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">hyphens&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c">/* 西文自动断词，包括以下两个 -&amp;lt;vendor&amp;gt;-hyphens 的兼容性选项 */&lt;/span>
&lt;span class="kp">-webkit-&lt;/span>&lt;span class="k">hyphens&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kp">-moz-&lt;/span>&lt;span class="k">hyphens&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">auto&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>对比下以下两种排版效果，第一段是是默认的 1.75 行距两端对齐段落，第二段是 1.5 行距左对齐段落：&lt;/p>
&lt;p>Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.&lt;/p>
&lt;p lang="en">Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.&lt;/p>
&lt;!-- ![不同 lang 属性下的段落显示效果](https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200406001130.png#border "不同 lang 属性下的段落显示效果") -->
&lt;p>相较于上面第一段的默认效果，用 &lt;em>lang=&amp;ldquo;en&amp;rdquo;&lt;/em> 描述的段落的 &lt;em>1.5&lt;/em> 倍行距更加紧凑，文本左对齐和自动断词达到了更加贴近英文印刷品的排版效果，如果你的浏览器宽度恰好，甚至能看到行尾的 “&lt;span lang="en">a new nation&lt;/span>” 进行了连字符折断。&lt;/p>
&lt;h2 id="字体与字号">字体与字号&lt;/h2>
&lt;p>中西文字体分别使用 &lt;a href="https://fonts.google.com/specimen/Noto+Serif+SC/">思源宋体&lt;/a> 和 &lt;a href="https://fonts.google.com/specimen/Zilla+SLab/">Zilla Slab&lt;/a>，从 &lt;a href="https://fonts.google.com/">Google Fonts&lt;/a> 加载，字号为 16px，确定字体大小后保证每行字数在 38～42，CSS 的配置为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-css" data-lang="css">&lt;span class="p">@&lt;/span>&lt;span class="k">import&lt;/span> &lt;span class="nt">url&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&amp;amp;family=Zilla+Slab:ital,wght@0,400;0,600;1,400;1,600&amp;amp;display=swap&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="nt">body&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">font-size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="kt">px&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">font-family&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;Zilla Slab&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Noto Serif SC&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">serif&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>统一的字体是为了各平台下的显示效果完全一致，给读者连续的阅读体验，代价是在读者本地没有安装对应字体的情况下，页面有字体请求的网络开销。&lt;/p>
&lt;h3 id="思源系列字体">思源系列字体&lt;/h3>
&lt;p>思源系列字体是 Google 和 Adobe 联合开发的开源免费字体集（Google 称作 Noto 系列，Adode 称作 Source 系列），特点是设计优雅，可读性高，对 CJK 书写系统的支持很好，任何人都可免费下载和几乎在任何地方使用，宋体相对于黑体增加的笔锋更加接近于书本的效果，更具文字美感。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200405182812.png#border" alt="思源宋体：开源的泛 CJK 字体">&lt;/p>
&lt;p>基于以上诸多优点，我建议每个人的电脑里都应该安装思源系列字体。&lt;/p>
&lt;h3 id="衬线体与无衬线体">衬线体与无衬线体&lt;/h3>
&lt;p>另一个问题是，正文选用衬线体还是无衬线体？即选用宋体还是黑体。&lt;/p>
&lt;p>如果是五年前，无笔锋的黑体更适合，黑体在中低分辨率屏幕的可读性更好，尤其是各平台默认黑体几乎是最安全的选择。现在则凭个人喜好，一方面开源的衬线体比如思源宋体获取门槛降低，另一方面随着 Web 技术和显示器分辨率的进步，使用衬线体的效果渐渐不再逊色于无衬线体，甚至能呈现更逼真的纸张模拟。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200405182754.png#border" alt="衬线思源宋体（上）与无衬线苹方（下）的显示效果对比" title="衬线思源宋体（上）与无衬线苹方（下）的显示效果对比">&lt;/p>
&lt;p>另外，正文中的无衬线字体应当降低颜色对比度，让文本整体更加偏灰以减少攻击性和视觉冲击，比如下图中 &lt;a href="https://sspai.com/">少数派&lt;/a> 页面的正文效果：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200405183037.png#border" alt="少数派的正文字体颜色偏灰" title="少数派的正文字体颜色偏灰">&lt;/p>
&lt;h2 id="hancss">Han.css&lt;/h2>
&lt;p>&lt;a href="https://github.com/ethantw/Han/">Han.css&lt;/a> 是一套用于 Web 的汉字排版解决方案，作为已有 CSS 的补充为网页提供了丰富地用于汉字书写系统的特性，尤其针对那些已有 CSS 属性无法支持的排版特性比如：&lt;/p>
&lt;ul>
&lt;li>中西文间混排 &lt;em>.25em&lt;/em> 间隙，即所谓的盘古之白&lt;/li>
&lt;li>标点挤压&lt;/li>
&lt;li>标点悬挂&lt;/li>
&lt;li>其他样式等&lt;/li>
&lt;/ul>
&lt;p>Han.css 可对页面整体使用，也可对某个子元素使用，甚至是只开启部分功能。出于摸索阶段的谨慎，我只开启了标点挤压功能。&lt;/p>
&lt;p>标点挤压是指：汉字排版连续使用多个符号时，字与字间将出现一个汉字宽度的空隙，不甚美观，而用额外的 JavaScript 脚本缩减连续标点及行首／行尾标点的多余空间。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200405182709.png#border" alt="博客中使用了标点挤压模式 B" title="博客中使用了标点挤压模式 B（图来自 The Type）">&lt;/p>
&lt;h3 id="启用标点挤压">启用标点挤压&lt;/h3>
&lt;p>在头部引入 Han.css 的脚本和样式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">link&lt;/span> &lt;span class="na">rel&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;stylesheet&amp;#34;&lt;/span> &lt;span class="na">media&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;all&amp;#34;&lt;/span> &lt;span class="na">href&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">script&lt;/span> &lt;span class="na">src&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.js&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>引入 Han.css 相关的 JavaScript 依赖后，在网页中插入以下脚本即可开启 &lt;em>&amp;lt;body&amp;gt;&lt;/em> 元素下的标点挤压：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;span class="nb">window&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">addEventListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;DOMContentLoaded&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Han&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">document&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">.&lt;/span>&lt;span class="nx">initCond&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 初始化脚本
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="nx">renderJiya&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 渲染标点挤压
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">})&lt;/span>
&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>开启前后的效果对比如下图所示，注意第二行的右括号和逗号的处理：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200406001103.png#border" alt="" title="启用标点挤压（上）和无标点挤压（下）的效果对比">&lt;/p>
&lt;p>因为目前的 CSS 标准并没有覆盖到该特性，所以这项技术的本质是依赖外部样式和脚本做后置渲染。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;h3 id="首行缩进">首行缩进&lt;/h3>
&lt;p>MemE 主题的正文的分段样式有两种选择，&lt;span lang="en">margin&lt;/span> 和 &lt;span lang="en">indent&lt;/span>，前者就是一般的依靠 CSS 上下外边距分隔段落，后者是类似书本的首行缩进，这里的选用凭个人喜好，具体见 MemE 主题的 &lt;a href="https://github.com/reuixiy/hugo-theme-meme/blob/a323e45d5ece0afb741fe90b495a723698600b8c/config-examples/zh-cn/config.toml#L916/">配置文件&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200406001535.png#border" alt="margin 和 indent 的区别" title="margin 和 indent 的区别">&lt;/p>
&lt;h3 id="何时使用-italic">何时使用 italic&lt;/h3>
&lt;p>另外就是，技术文章中大量用到的「类型名」、「函数名」、「变量名」。严格意义上应当使用 &lt;em>&amp;lt;var&amp;gt;&lt;/em> 标签标记，但考虑到 Markdown 里面没有类似的语法，所以我参照 &lt;a href="https://www.baeldung.com/">Baeldung&lt;/a> 的样式，使用 &lt;em>&amp;lt;em&amp;gt;&lt;/em> 标签标记，比如下图中的 &lt;em>SearchCriteria&lt;/em> 作为类型名称被渲染成了斜体。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20200401205159.jpg#border" alt="Bealdung 网站的文本使用 标签描述类型名" title="Bealdung 网站的文本使用 &amp;lt;em&amp;gt; 标签描述类型名">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在「够看」的情况下继续深入优化排版，像对待印刷品一样对待 Web 页面，是一种工匠精神的体现，但另一方面我们又不得不面对一个尴尬的现实：文中所提到的那些高阶排版技巧，除了已经纳入 CSS 标准的特性外，有些需要微调页面元素，有些需要 JavaScript 脚本参与，有些则要求打字者一一手动校对，而 Web 网页作为「快速消费品」，大多数用户根本不会注意到这些额外的排版特性带来的效果增益，所以浏览器也没有足够的理由为支持这些特性而投入成本。&lt;/p>
&lt;p>就像《死亡搁浅》中场景里的某朵小花，它会在你送快递的时候于视野中一闪而过，构成你对游戏整体体验的一部分，但是如果没有它，也不影响你继续游戏过程，更不会降低你对《死亡搁浅》的评价。&lt;/p>
&lt;p>但是，这不能成为我们对 Web 排版满足现状的理由，因为排版的意义在于让人类更加舒适地阅读文字 &amp;mdash; 每纠正一个标点符号，每对齐一行文本，每划分一个段落，都是对艺术和美的追求。&lt;/p>
&lt;p>最后，技术总是在进步，我们在 HTML 页面上对美学的要求总会随着标准草案的迭代和 Web 基础能力的支持而不断向前。可以肯定的是，Web 页面的质量将会无限趋近甚至超越纸质印刷品，现有的标准也会逐渐覆盖人类所有的语言和书写系统，甚至是这些系统里的冷门而小众的特性。&lt;/p>
&lt;h2 id="延伸阅读">延伸阅读&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://w3c.github.io/clreq/">中文排版需求·W3C&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/sparanoid/chinese-copywriting-guidelines/">中文文案排版指北·GitHub&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hanzi.pro/">漢字標準格式 &amp;mdash; 印刷品般的汉字排版框架&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.thetype.com/2015/04/9171/">从《中文排版需求》开始·The Type&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learnku.com/docs/writing-docs/">社区文档撰写指南·LearnKu 产品论坛&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.thetype.com/2018/04/14734/">针对 Adobe InDesign 标点挤压中文默认设置的反馈·The Type&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zzao.im/blog/post/left-or-justify.html">排版左对齐（left）与两端对齐（justify）的思考·Hungl Zzz&amp;rsquo;s Blog&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.codesandnotes.com/front-end/word-breaking-in-east-asian-languages/">&lt;span lang="en" class="latin">Word breaking online in East Asian languages·Code &amp;amp; Notes&lt;/span>&lt;/a>&lt;/li>
&lt;/ul>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>摘录自 &lt;a href="https://www.codesandnotes.com/front-end/word-breaking-in-east-asian-languages/">Code &amp;amp; Notes&lt;/a>，原文为：&lt;/p>
&lt;blockquote>
&lt;p lang="en">
Latin and other Western language systems use spaces and punctuation to separate words. East Asian Languages as Japanese, Chinese and sometimes also Korean however do not. Instead they rely on syllable boundaries. In these systems a line can break anywhere except between certain character combinations.
&lt;/p>
&lt;/blockquote>
&amp;#160;&lt;a href="https://zhix.co/posts/talking-typesetting/#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;/ol>
&lt;/section></description><category domain="https://zhix.co/categories/%E8%AE%BE%E8%AE%A1/">设计</category><category domain="https://zhix.co/series/%E6%8E%92%E7%89%88%E5%AD%A6/">排版学</category><category domain="https://zhix.co/tags/%E5%8D%9A%E5%AE%A2/">博客</category><category domain="https://zhix.co/tags/%E8%AE%BE%E8%AE%A1/">设计</category><category domain="https://zhix.co/tags/%E6%8E%92%E7%89%88/">排版</category><category domain="https://zhix.co/tags/%E5%AD%97%E4%BD%93/">字体</category><category domain="https://zhix.co/tags/css/">css</category><category domain="https://zhix.co/tags/baeldung/">baeldung</category><category domain="https://zhix.co/tags/markdown/">markdown</category><category domain="https://zhix.co/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/">公众号</category></item><item><title>在 Spring Cache 中为 Redis 添加内存缓存</title><link>https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/</link><guid isPermaLink="true">https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/</guid><pubDate>Sun, 29 Mar 2020 12:44:41 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;p>缓存是提升应用程序性能的首要途径，我们一般会使用 Redis 来实现缓存层以减小对持久层的访问压力，随之带来的问题是：即便在缓存命中的情况下，应用程序依然需要访问 Redis 服务器并消耗一定的 CPU 算力和网络带宽资源，随着业务量增长，代价可能变得更加明显。本文将以 Spring Cache 为背景，探讨如何以最小化的改动来实现给 Redis 加持内存缓存。&lt;/p>
&lt;h2 id="spring-cache-抽象">Spring Cache 抽象&lt;/h2>
&lt;p>&lt;a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/integration.html#cache">Spring Cache&lt;/a> 作为 Spring 最核心的模块之一，提供了开箱即用的缓存支持，应用程序只需要在任意 &lt;em>Configuration&lt;/em> 类上加入注解 &lt;em>@EnableCaching&lt;/em> 即可启用缓存：&lt;/p>
&lt;p>Spring Cache 的实现位 &lt;em>org.springframework.cache&lt;/em> 包下，如果使用 Maven 的话需要引入 &lt;a href="https://search.maven.org/search?q=g:org.springframework%20a:spring-context">&lt;em>spring-context&lt;/em>&lt;/a> 模块，其中最核心的 2 个接口定义如下：&lt;/p>
&lt;dl>
&lt;dt>&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/Cache.html">&lt;em>Cache&lt;/em>&lt;/a>&lt;/dt>
&lt;dd>代表通用缓存对象的抽象，定义了与缓存交互的接口，包含基本的读取、写入、淘汰和清空操作，管理一系列的缓存键值对，按键寻址，拥有唯一的名称。&lt;/dd>
&lt;dt>&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/CacheManager.html">&lt;em>CacheManager&lt;/em>&lt;/a>&lt;/dt>
&lt;dd>代表缓存管理器的抽象，管理一系列缓存对象，按名称寻址缓存。&lt;/dd>
&lt;/dl>
&lt;p>一句话概括就是：Spring 在核心模块 &lt;em>spring-context&lt;/em> 就包含了对缓存的支持，通过注解 &lt;em>@EnableCaching&lt;/em> 来使用。需要被缓存的对象由 &lt;em>Cache&lt;/em> 管理并按键寻址，&lt;em>Cache&lt;/em> 按照名称区分彼此，统一地注册在 &lt;em>CacheManager&lt;/em> 中&lt;sup id="fnref:1">&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p>
&lt;h2 id="concurrentmapcache-和-rediscache">ConcurrentMapCache 和 RedisCache&lt;/h2>
&lt;p>简单来说，&lt;em>Cache&lt;/em> 和 &lt;em>CacheManager&lt;/em> 定义了如何存储具体的缓存对象，是存储在本地还是远程服务器，实际的方式不同实现有不同表现，一般我们用得最多的实现要数以下两种：&lt;/p>
&lt;dl>
&lt;dt>&lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/concurrent/ConcurrentMapCache.html">&lt;em>ConcurrentMapCache&lt;/em>&lt;/a>&lt;/dt>
&lt;dd>基于 &lt;em>ConcurrentHashMap&lt;/em> 实现的本地缓存，也是此次的内存缓存实现类，对应的缓存管理器是 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/concurrent/ConcurrentMapCacheManager.html">&lt;em>ConcurrentMapCacheManager&lt;/em>&lt;/a>；&lt;/dd>
&lt;dt>&lt;a href="https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/cache/RedisCache.html">&lt;em>RedisCache&lt;/em>&lt;/a>&lt;/dt>
&lt;dd>基于 Redis 实现的分布式缓存，使用时需要引入 &lt;a href="https://search.maven.org/search?q=g:org.springframework%20a:spring-data-redis">&lt;em>spring-data-redis&lt;/em>&lt;/a> 依赖，对应的缓存管理器是 &lt;a href="https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/cache/RedisCacheManager.html">&lt;em>RedisCacheManager&lt;/em>&lt;/a>。&lt;/dd>
&lt;/dl>
&lt;h2 id="实现二级内存缓存">实现二级内存缓存&lt;/h2>
&lt;p>回到开头的问题，如果需要在 &lt;em>RedisCache&lt;/em> 存在的情况下，为应用程序加入内存二级缓存的支持，要如何做呢？典型的场景是，对于某个缓存键，若在本地内存缓存中存在，则使用内存缓存的值，否则查询 Redis 缓存，若存在，将取得的值回写入内存缓存中，流程图表示为：&lt;/p>
&lt;div class="mermaid">
graph TD;
Q[/Query Start/]
QE[/Query End/]
M([Memory])
R([Redis])
Q -->|KEY| M
M --> KP{Memory KEY exists?}
KP -->|Y| RMV[Return memory value]
RMV -->QE
KP -->|N| QR[Query Redis]
QR -->R
R --> RKP{Redis KEY exists?}
RKP --> |Y| WM[Write memory]
WM -->QE
RKP --> |N| DB[(Database)]
&lt;/div>
&lt;p>虽然 Spring 提供了名为 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/support/CompositeCacheManager.html">&lt;em>CompositeCacheManager&lt;/em>&lt;/a> 的实现来组合多个 &lt;em>CacheManager&lt;/em>，但也仅仅是在名称寻址时，迭代所管理的 &lt;em>CacheManager&lt;/em> 集合，返回第一个寻址不为 null 的 &lt;em>Cache&lt;/em> 对象，并不能完成上述的缓存回写的实现。&lt;/p>
&lt;p>我们可以用 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/support/AbstractCacheManager.html">&lt;em>AbstractCacheManager&lt;/em>&lt;/a> 的特性来解决这个问题，&lt;em>AbstractCacheManager&lt;/em> 提供了名为 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/support/AbstractCacheManager.html#decorateCache-org.springframework.cache.Cache-">&lt;em>decorateCache&lt;/em>&lt;/a> 的保护方法来对 &lt;em>Cache&lt;/em> 对象做封装，它的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Decorate the given Cache object if necessary.
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @param cache the Cache object to be added to this CacheManager
&lt;/span>&lt;span class="cm"> * @return the decorated Cache object to be used instead,
&lt;/span>&lt;span class="cm"> * or simply the passed-in Cache object by default
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="nf">decorateCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Cache&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>decorateCache&lt;/em> 方法的调用时机有 2 个：&lt;/p>
&lt;ol>
&lt;li>&lt;em>CacheManager&lt;/em> 初始化缓存；&lt;/li>
&lt;li>向 &lt;em>CacheManager&lt;/em> 请求了它所没有的缓存（&lt;span lang="en">Missing Cache&lt;/span>），且 &lt;em>CacheManager&lt;/em> 被配置成自动创建不存在的缓存时，&lt;em>decorateCache&lt;/em> 会在 &lt;span lang="en">Missing Cache&lt;/span> 被创建时被调用。&lt;sup id="fnref:2">&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/li>
&lt;/ol>
&lt;p>重载 &lt;em>decorateCache&lt;/em> 用的是典型的 &lt;a href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">装饰模式&lt;/a> 的思想，在子类中重写该方法，我们可以将参数中的 &lt;em>Cache&lt;/em> 对象包装成我们想要的实现，从而达到在不修改原有缓存的情况动态地下改变原缓存的行为。&lt;/p>
&lt;h3 id="缓存装饰器">缓存装饰器&lt;/h3>
&lt;p>首先我们展示一个缓存装饰器的简单示例，它在每次缓存读取和写入时打印一条日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SimpleLoggingCacheDecorator&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">LoggingCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Cache&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">delegate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="nf">getNativeCache&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNativeCache&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Nullable&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ValueWrapper&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ValueWrapper&lt;/span> &lt;span class="n">valueWrapper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">delegate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">debug&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Get cache value, key = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">valueWrapper&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nd">@Nullable&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">debug&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Put cache value, key = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">delegate&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 所有的方法都转发到委托对象，下同
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着继承现有的 &lt;em>CacheManager&lt;/em> 并重写 &lt;em>decorateCache&lt;/em> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="nf">decorateCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Cache&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">SimpleLoggingCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们就实现了在日志中捕捉缓存的方法调用，可以看出，通过装饰器模式，我们能够无侵入地修改原对象的行为，这也为我们后续进一步 hack 缓存提供了设计基础。&lt;/p>
&lt;h3 id="内存缓存装饰器">内存缓存装饰器&lt;/h3>
&lt;p>接下来我们沿用上一节的设计，尝试实现一个内存缓存的装饰器（&lt;span lang="en">Memory Cache Decorator&lt;/span>），它的作用是按照上述流程图所描述的逻辑来改变已有 Redis 缓存的行为。&lt;/p>
&lt;p>不难分析出，这个装饰器会具有如下特征：&lt;/p>
&lt;ol>
&lt;li>持有一个上游缓存的引用，并管理一个内存缓存；&lt;/li>
&lt;li>修改上游缓存读取方法的行为，在方法返回 null 时转而查询本地的内存缓存，依据查询的结果判断是否需要回写本地缓存；&lt;/li>
&lt;li>修改上游缓存写入方法的行为，在方法执行的同时也同步到到本地的内存缓存。&lt;/li>
&lt;/ol>
&lt;p>以下是它的部分代码实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryCacheDecorator&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">MemoryCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Cache&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">memory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ConcurrentMapCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;memory-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">source&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@NonNull&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="nf">getName&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@NonNull&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="nf">getNativeCache&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getNativeCache&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Nullable&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">ValueWrapper&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ValueWrapper&lt;/span> &lt;span class="n">valueWrapper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">valueWrapper&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">valueWrapper&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">valueWrapper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">source&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">valueWrapper&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">memory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">valueWrapper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">valueWrapper&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nd">@Nullable&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">source&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">memory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 其他的 GET/PUT 方法省略
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>MemoryCacheDecorator&lt;/em> 的逻辑并不复杂，仅仅是拦截了上游缓存的读取操作，其中：&lt;/p>
&lt;ul>
&lt;li>第 8 行创建了替代上游缓存的内存缓存对象，采用 &lt;em>ConcurrentMapCache&lt;/em> 实现，为了健壮起见，内存缓存的名称是上游缓存名称前加 &lt;code>memory-&lt;/code>；&lt;/li>
&lt;li>第 27 ～ 35 行是真正起作用的部分：先查询内存缓存，依据结果判断是否需要进一步查询上游缓存，且保证查询上游缓存后回写内存缓存以保证一致性；&lt;/li>
&lt;li>同样为健壮起见，在上游缓存被修改时也需要同步到内存缓存中，如第 41 行所示。&lt;/li>
&lt;/ul>
&lt;h3 id="扩展-rediscachemanager">扩展 RedisCacheManager&lt;/h3>
&lt;p>现在是时候扩展现有的缓存管理器了，由于上游缓存是 &lt;em>RedisCache&lt;/em>，我们需要扩展它所对应的缓存管理器 &amp;mdash; &lt;em>RedisCacheManager&lt;/em>，并重写 &lt;em>decorateCache&lt;/em> 方法，代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryRedisCacheManager&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">RedisCacheManager&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 构造方法省略
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="nd">@NonNull&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="nf">decorateCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MemoryCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在任何用到 &lt;em>RedisCacheManager&lt;/em> 的地方使用 &lt;em>MemoryRedisCacheManager&lt;/em> 替换，保证程序中最终起作用的 &lt;em>CacheManager&lt;/em> 是我们实现的 &lt;em>MemoryRedisCacheManager&lt;/em> 即可。&lt;/p>
&lt;p>此时所有的 &lt;em>Cache&lt;/em> 对象在初始化时，都会被包装成 &lt;em>MemoryCacheDecorator&lt;/em> 类型，在读取和写入时会先从内存缓存中查询，这样便完成了二级缓存的实现。&lt;/p>
&lt;p>实际上，按照这样的方式上游缓存不一定是 &lt;em>RedisCache&lt;/em>，任何可以远程缓存比如 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/ehcache/EhCacheCache.html">&lt;em>EhCacheCache&lt;/em>&lt;/a> 也可以通过这样的方式来整合本地二级缓存。&lt;/p>
&lt;h2 id="内存缓存的优化">内存缓存的优化&lt;/h2>
&lt;p>虽然通过扩展 &lt;em>RedisCacheManager&lt;/em> 类和少量代码便能实现本地的内存缓存，但这也只是完成了第一步，现在的代码如果在生产环境使用仍然具有不少问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>缓存过期&lt;/strong>：我们没有确定内存缓存何时过期，Redis 缓存的过期由 Redis 服务器的键过期能力来保证，但 &lt;em>ConcurrentMapCache&lt;/em> 没有。况且实际的服务通常是集群部署，存在着多个实例负载均衡，因此各个实例之间的缓存一致性也是需要考虑的，否则可能出现用户访问的结果同时存在新旧两个版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>序列化与线程安全&lt;/strong>：&lt;em>ConcurrentMapCache&lt;/em> 中默认保存的是缓存值本身，即多线程环境下各个线程对同一个缓存键获取的值是同一个对象实例。若其中一个线程修改了该实例，则会其他线程的读取，比如一个业务读取缓存中的配置数据，根据自己的业务逻辑修改了对象的字段，由于对象只有一份，这个修改将会被所有其他线程知晓。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>条件化启用&lt;/strong>：业务中的缓存可能会分为用户数据的缓存（热数据）和配置数据的缓存（冷数据）两组，不同组的缓存修改的频率不同，比如用户缓存随着用户行为的发生而被淘汰，而配置数据的更新频率往往是按周来算，因此我们一般只会对不常变化的配置数据做内存二级缓存，这就要求 &lt;em>CacheManager&lt;/em> 条件化地对 &lt;em>Cache&lt;/em> 进行装饰。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>基于以上 3 点，我们可以对现有代码做优化。&lt;/p>
&lt;h3 id="缓存过期">缓存过期&lt;/h3>
&lt;p>内存缓存需要过期（严格来说是清空），并且最好是所有服务实例在同一时间点过期，典型的解决方案就是基于 &lt;a href="https://www.baeldung.com/cron-expressions">Cron 表达式&lt;/a> 的定时任务。&lt;/p>
&lt;p>Spring 中设置 Cron 定时任务的方式非常方便，如果服务已经配置了启用定时任务的注解 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/EnableScheduling.html">&lt;em>@EnableScheduling&lt;/em>&lt;/a>，则可以让我们的缓存管理器简单地实现 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html">&lt;em>SchedulingConfigurer&lt;/em>&lt;/a> 接口，如果没有配置的话，定时任务也是 Spring 的 &lt;em>spring-context&lt;/em> 模块就支持的，不需要引入其他的依赖。在此之前，首先让 &lt;em>MemoryCacheDecorator&lt;/em> 提供一个公共的清理内存缓存的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryCacheDecorator&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">cleanMemoryCache&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">memoryCache&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">clear&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再让缓存管理器注册 Cron 定时任务，比如按每分钟的第 30 秒执行清空：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryRedisCacheManager&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">RedisCacheManager&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">SchedulingConfigurer&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">configureTasks&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">ScheduledTaskRegistrar&lt;/span> &lt;span class="n">taskRegistrar&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 向容器注册清理缓存的 CRON 任务，若没有配置 @EnableScheduling，这里不会执行，需要手动调用 clearMemoryCache 清理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">taskRegistrar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addCronTask&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">clearMemoryCache&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">clearCacheCronExpression&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Register cron task for clear memory cache, cron = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">clearCacheCronExpression&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="cm">/** 手动清理所有内存缓存。 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">clearMemoryCache&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Collection&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">cacheNames&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getCacheNames&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">cacheName&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">cacheNames&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Cache&lt;/span> &lt;span class="n">cache&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cacheName&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(!(&lt;/span>&lt;span class="n">cache&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="n">MemoryCacheDecorator&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 对所有 MemoryCacheDecorator 类型的缓存做清理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">MemoryCacheDecorator&lt;/span> &lt;span class="n">memoryCacheDecorator&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">MemoryCacheDecorator&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">memoryCacheDecorator&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">cleanMemoryCache&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就能保证所有的服务实例，几乎在同一时间点清空内存缓存。&lt;sup id="fnref:3">&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h3 id="序列化">序列化&lt;/h3>
&lt;p>缓存的序列化机制通过复制对象来保证线程安全，如果每次从缓存中获取到的总是全新的对象，那么就不存在上述的多线程修改缓存对象互相影响的问题。&lt;/p>
&lt;p>&lt;em>ConcurrentMapCache&lt;/em> 可以在 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/concurrent/ConcurrentMapCache.html#ConcurrentMapCache-java.lang.String-java.util.concurrent.ConcurrentMap-boolean-org.springframework.core.serializer.support.SerializationDelegate-">构造方法&lt;/a> 中指定一个 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/serializer/support/SerializationDelegate.html">序列化实现&lt;/a>。若指定了序列化实现，则被缓存的对象会经由序列化转化成字节数组保存，否则直接保存对象引用，同时在读取的时候将字节数组反序列化成对象。。&lt;/p>
&lt;p>&lt;em>ConcurrentMapCache&lt;/em> 序列化机制的接口定义于 &lt;a href="https://search.maven.org/search?q=g:org.springframework%20a:spring-core">&lt;em>spring-core&lt;/em>&lt;/a> 中，Spring 自身只提供了 JDK 序列化版本的实现&lt;sup id="fnref:4">&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>。其实大多数情况下这两个类足以满足要求，不过因为是 JDK 序列化，所以对于被序列化的类有诸多的要求，比如必须实现 &lt;em>Serializable&lt;/em> 接口，而且众所周知，JDK 序列化的性能低于其他序列化实现。这里我们选择 JSON 序列化，并且使用 &lt;a href="https://github.com/alibaba/fastjson">Fastjson&lt;/a> 来实现。&lt;/p>
&lt;p>得益于 Fastjson 的简单性，最终实现的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">FastjsonSerializationDelegate&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Serializer&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;,&lt;/span> &lt;span class="n">Deserializer&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ParserConfig&lt;/span> &lt;span class="n">ENABLE_AUTO_TYPE_PARSER_CONFIG&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ParserConfig&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kd">static&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 使用非全局的 ParserConfig 并设置支持 autoType
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ENABLE_AUTO_TYPE_PARSER_CONFIG&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setAutoTypeSupport&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@NonNull&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="nf">deserialize&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">InputStream&lt;/span> &lt;span class="n">inputStream&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 读取所有 inputStream 中的数据至字节数组中，很多库的 I/O 工具类都能做到
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">IOUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toByteArray&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">inputStream&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">String&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">StandardCharsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">UTF_8&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">JSON&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parseObject&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">inputStream&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">serialize&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Object&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">OutputStream&lt;/span> &lt;span class="n">outputStream&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 这里需要带上 SerializerFeature.WriteClassName，否则 List&amp;lt;Long&amp;gt; 经过序列化反序列化会变成 List&amp;lt;Integer&amp;gt;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">JSON&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">writeJSONString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">outputStream&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">SerializerFeature&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">WriteClassName&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要注意的就是第 17 行的调用中需要加入 &lt;em>WriteClassName&lt;/em> 的序列化特性，否则 &lt;em>List&amp;lt;Long&amp;gt;&lt;/em> 在序列反序列化后会被解析成 &lt;em>List&amp;lt;Integer&amp;gt;&lt;/em>。另外，&lt;em>Fastjson&lt;/em> 在版本 1.2.25 之后限制了 JSON 反序列化时的类型解析功能，所以我们在第 4 行使用一个非全局的 &lt;em>ParserConfig&lt;/em> 对象，单独对该对象启用 &lt;em>autoType&lt;/em> 并在第 19 行使用，如果不指定的话就会使用全局的对象&lt;sup id="fnref:5">&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>，这样可能出现 &lt;em>autotype is not support&lt;/em> 报错。具体的配置可以参阅官方的 &lt;a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315#2-%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%90%8E%E6%8A%A5%E9%94%99autotype-is-not-support">升级公告&lt;/a> 和 &lt;a href="https://github.com/alibaba/fastjson/wiki/enable_autotype">enable_autotype&lt;/a> 配置。&lt;/p>
&lt;p>接着扩展 &lt;em>ConcurrentMapCache&lt;/em> 类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">FastjsonSerializationConcurrentMapCache&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">ConcurrentMapCache&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="cm">/** 该缓存的 FastJson 序列化实现。 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">FastjsonSerializationDelegate&lt;/span> &lt;span class="n">SERIALIZATION_DELEGATE&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="n">FastjsonSerializationDelegate&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">FastjsonSerializationConcurrentMapCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="n">ConcurrentHashMap&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">256&lt;/span>&lt;span class="o">),&lt;/span>
&lt;span class="kc">true&lt;/span>&lt;span class="o">,&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="n">SerializationDelegate&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">SERIALIZATION_DELEGATE&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">SERIALIZATION_DELEGATE&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后在 &lt;em>MemoryCacheDecorator&lt;/em> 的构造方法中替换原来的 &lt;em>ConcurrentMapCache&lt;/em>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryCacheDecorator&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">ConcurrentMapCache&lt;/span> &lt;span class="n">memoryCache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">targetCache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">MemoryCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">targetCache&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// this.memoryCache = new ConcurrentMapCache(&amp;#34;memory-&amp;#34; + targetCache.getName());
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">memoryCache&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="n">FastjsonSerializationConcurrentMapCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;memory-&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">targetCache&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">targetCache&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">targetCache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>缓存对象实际以 JSON 字符串的形式保存在内存中，并且带有字段的类型信息，每次访问的结果都是全新的反序列化对象，这样就实现了内存缓存的线程安全访问。&lt;/p>
&lt;h3 id="条件化启用">条件化启用&lt;/h3>
&lt;p>条件化启用应该是最好实现的一点优化了，只需要在构造方法中加入一个列表，在 &lt;em>decorateCache&lt;/em> 方法中判断属于列表中的缓存才做包装，类似的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MemoryRedisCacheManager&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">RedisCacheManager&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">SchedulingConfigurer&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="cm">/** 只有这里配置的缓存才会加持内存缓存层。 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">decoratedCacheNameList&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * 覆盖 {@link AbstractCacheManager} 的装饰缓存方法，若参数中的缓存包含 {@link #decoratedCacheNameList}
&lt;/span>&lt;span class="cm"> * 中，则在将该对象包装成具有内存缓存能力的对象。
&lt;/span>&lt;span class="cm"> *
&lt;/span>&lt;span class="cm"> * @see AbstractCacheManager
&lt;/span>&lt;span class="cm"> * @param cache 原缓存对象
&lt;/span>&lt;span class="cm"> * @return 原缓存对象或具有内存缓存能力的对象
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="nd">@NonNull&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="nf">decorateCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@NonNull&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 先让基类包装一次
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">Cache&lt;/span> &lt;span class="n">superCache&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">decorateCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="c1">// 判断是否为该缓存配置了内存缓存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">decoratedCacheNameList&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()))&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 包装缓存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MemoryCacheDecorator&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">superCache&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 不包装缓存
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">superCache&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我们介绍了 Spring Cache 的 2 个核心接口，以及基于 Spring Cache 来为 Redis 缓存建立二级本地内存缓存，也讨论了如何在这个基础上做优化以便生产环境使用。&lt;/p>
&lt;p>实现的方法基于 &lt;em>AbstractCacheManager&lt;/em> 的 &lt;em>decorateCache&lt;/em> 函数，重写该方法可以将原本的 &lt;em>Cache&lt;/em> 对象封装成另一个 &lt;em>Cache&lt;/em> 对象，借此我们可以改变原有缓存的行为，最终以新增不超过 5 个类的代价，将核心逻辑内聚在 &lt;em>RedisCacheManager&lt;/em> 的子类中，也易于未来的扩展，具体的详情可以参考我的 GitHub 项目 &lt;a href="https://github.com/wzhix/memory-cache-in-redis">memory-cache-in-redis&lt;/a>。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>如何使用 Spring Cache 以及如何集成 Redis 不在本文的讨论范围内，相关的内容可以参阅 Baeldung 的 &lt;a href="https://www.baeldung.com/spring-cache-tutorial">A Guide To Caching in Spring&lt;/a>、IBM 知识库的 &lt;a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/index.html">注释驱动的 Spring Cache 缓存介绍&lt;/a>。Redis Cache 的相关内容可以参阅 &lt;a href="https://docs.spring.io/spring-data/redis/docs/2.2.6.RELEASE/reference/html/#redis:support:cache-abstraction">Spring Data Redis 官方文档章节&lt;/a>。&amp;#160;&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>个人认为不应当让 &lt;em>CacheManager&lt;/em> 自动创建缺失的缓存，而是在一开始就确定程序的缓存命名空间，并创建好所有类型的缓存。&amp;#160;&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>Cron 表达式依照机器本地时间执行，不同机器本地时间可能存在分钟级差异，为了追求更高的一致性，应当用外部手段保证各个机器时间戳尽量趋近，比如时间服务器。&amp;#160;&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>将对象类型的名称序列化至 JSON，在反序列化时可能存在安全问题，比如指定 JSON 反序列化后的类型为 &lt;code>java.lang.Thread&lt;/code>，就能通过非常规方法创建线程。&amp;#160;&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p> 即 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/serializer/DefaultSerializer.html">&lt;em>DefaultSerializer&lt;/em>&lt;/a> 和 &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/serializer/DefaultDeserializer.html">&lt;em>DefaultDeserializer&lt;/em>&lt;/a>。&amp;#160;&lt;a href="https://zhix.co/posts/spring-cache-in-practice-adding-memory-cache-in-front-of-redis-cache/#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/series/spring-framework/">Spring Framework</category><category domain="https://zhix.co/tags/java/">Java</category><category domain="https://zhix.co/tags/%E7%BC%96%E7%A8%8B/">编程</category><category domain="https://zhix.co/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category><category domain="https://zhix.co/tags/%E7%BC%93%E5%AD%98/">缓存</category><category domain="https://zhix.co/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</category><category domain="https://zhix.co/tags/cache/">cache</category><category domain="https://zhix.co/tags/spring-framework/">Spring Framework</category><category domain="https://zhix.co/tags/spring-cache/">spring cache</category><category domain="https://zhix.co/tags/redis/">redis</category></item><item><title>为你的 API 提供客户端脚本支持</title><link>https://zhix.co/posts/providing-scripting-support-for-your-api/</link><guid isPermaLink="true">https://zhix.co/posts/providing-scripting-support-for-your-api/</guid><pubDate>Mon, 16 Mar 2020 18:52:46 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="nashorn-脚本引擎">Nashorn 脚本引擎&lt;/h2>
&lt;h2 id="request-作用域的-bean">Request 作用域的 Bean&lt;/h2>
&lt;h2 id="未来版本可能的变化">未来版本可能的变化&lt;/h2></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/tags/java/">Java</category><category domain="https://zhix.co/tags/%E7%BC%96%E7%A8%8B/">编程</category><category domain="https://zhix.co/tags/spring-framework/">Spring Framework</category><category domain="https://zhix.co/tags/spring-mvc/">Spring MVC</category><category domain="https://zhix.co/tags/api/">API</category><category domain="https://zhix.co/tags/restful/">RESTful</category><category domain="https://zhix.co/tags/scripting/">Scripting</category><category domain="https://zhix.co/tags/%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E/">脚本引擎</category></item><item><title>谈谈 Java SPI：以字符集举例</title><link>https://zhix.co/posts/talking-spi-in-java/</link><guid isPermaLink="true">https://zhix.co/posts/talking-spi-in-java/</guid><pubDate>Wed, 11 Mar 2020 20:12:51 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;p>自 Java 6.0 开始，JDK 提供了名为 SPI（&lt;span lang="en">Service Provider Interface&lt;/span>）的加载机制，SPI 能够在运行时发现某个接口／抽象类的实现类，为接口消费方提供了一致的模型来使用接口，对于接口实现方，按 SPI 的规范注册的实现类可实现运行时自动加载。这种方式既解除了接口与实现的耦合，又解决了实现类的自动初始化，比较典型的用例有 JDBC 驱动类的注册、&lt;em>Charset&lt;/em> 字符集注册等，Spring Framework 和 Dubbo 的代码中也或多或少参考和封装了该机制。&lt;/p>
&lt;h2 id="spi-机制">SPI 机制&lt;/h2>
&lt;p>在 SPI 里，接口或者抽象类被称为服务（&lt;span lang="en">Service&lt;/span>）或服务提供者接口（&lt;span lang="en">Service Provider Interface&lt;/span>），实现类被称为服务提供者（&lt;span lang="en">Service Provider&lt;/span>）。虽然常见的概念被赋予了不太好理解的名称，但是二者在本质上还是代表了面向对象编程中规范（&lt;span lang="en">Specification&lt;/span>）和实现（&lt;span lang="en">Implementation&lt;/span>）的关系。&lt;/p>
&lt;h3 id="服务提供者">服务提供者&lt;/h3>
&lt;p>在 SPI 的规范中，服务提供者的实现类应当配置在资源目录下的 &lt;em>META-INF/services&lt;/em> 目录&lt;sup id="fnref:1">&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>下。该目录下，每一个服务接口对应一个单独的文本文件，文件名为服务接口的完全限定名，文件内容按行区分，每一行是服务实现类的完全限定名&lt;sup id="fnref:2">&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>SPI 的核心类是范型类 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">&lt;em>ServiceLoader&lt;/em>&lt;/a>，它负责发现类路径中配置的实现类并实例化它们。&lt;em>ServiceLoader&lt;/em> 维护了一个 &lt;em>LinkedHashMap&amp;lt;String, T&amp;gt;&lt;/em> 的内部缓存来惰性实例化实现类，其中类型 &lt;em>T&lt;/em> 为服务接口类。&lt;em>ServiceLoader.load(T.class)&lt;/em> 是最常调用的方法，它返回类型 &lt;em>T&lt;/em> 的 &lt;em>ServiceLoader&lt;/em> 实例。&lt;sup id="fnref:3">&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="charset-的加载方式">Charset 的加载方式&lt;/h2>
&lt;p>JDK 以 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/spi/CharsetProvider.html">&lt;em>CharsetProvider&lt;/em>&lt;/a> 来实现字符集框架。Oracle JDK 扩展了该实现，提供了标准字符集和扩展字符集的 Provider 实现（&lt;em>StandardCharsets&lt;/em> 和 &lt;em>ExtendedCharsets&lt;/em>）：&lt;/p>
&lt;dl>
&lt;dt>&lt;em>StandardCharsets&lt;/em>&lt;/dt>
&lt;dd>
&lt;p>标准字符集提供者，包括 Unicode 和 ASCII 字符集的管理；&lt;/p>
&lt;/dd>
&lt;dt>&lt;em>ExtendedCharsets&lt;/em>&lt;/dt>
&lt;dd>
&lt;p>扩展字符集提供者，包括 CJK 字符集的管理。&lt;/p>
&lt;/dd>
&lt;/dl>
&lt;p>这两个类都是在 &lt;em>sun.nio.cs&lt;/em> 包下。&lt;/p>
&lt;p>在 Java 中我们通过调用 &lt;em>Charset.forName(&amp;ldquo;charset-name&amp;rdquo;)&lt;/em> 来访问字符集 API，&lt;em>forName&lt;/em> 方法在底层会进行一系列的 lookup 操作，按照标准字符集提供者、扩展字符集提供者和 SPI 字符集提供者的顺序查询 charset-name 对应的字符集实现类，当无法在前两个内置的字符集提供者中找到对应名称的字符集实现，SPI 字符集提供者便会起作用，SPI 字符集提供者以接口 &lt;em>CharsetProvider&lt;/em> 为核心，因此我们可以为该接口插入自己的实现类。&lt;/p>
&lt;h2 id="安装自定义字符集">安装自定义字符集&lt;/h2>
&lt;p>假设现在有一个比 UTF-8 更高效且通用的字符串编码算法，它相对于 UTF-8 可能信噪比更低、更适合压缩甚至是支持火星语编码，我们暂且叫它 9527。它的编解码算法已经公开，我们现在需要赶在 Oracle 发布新的 JDK 支持它之前将它嵌入到我们的应用程序中，并且程序只需要将使用字符集的地方替换为 &lt;em>Charset.forName(&amp;ldquo;9527&amp;rdquo;)&lt;/em> 即可。&lt;/p>
&lt;h3 id="定义字符集">定义字符集&lt;/h3>
&lt;p>首先我们需要一个实现类继承自 &lt;em>java.nio.charset.Charset&lt;/em>，&lt;em>Charset&lt;/em> 是所有字符集的基类。在该案例中的实现类假设叫做 &lt;em>_9527Charset&lt;/em>，并且为方便示例，我们假定 &lt;em>_9527Charset&lt;/em> 本质上就是 UTF-8 的实现，因此它会持有一个 UTF-8 的实例，对它的所有方法调用都会被转发至 UTF-8 对应的方法中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">zhix.encoding.spi&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">_9527Charset&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Charset&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 为方便示例，假定 _9527Charset 本质上就是 UTF-8 的实现
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Charset&lt;/span> &lt;span class="n">DELEGATE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StandardCharsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">UTF_8&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">_9527Charset&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 名称和别名集合
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;9527&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="s">&amp;#34;mew-9527&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;mew&amp;#34;&lt;/span>&lt;span class="o">});&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 所有的方法调用一并转发
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Charset&lt;/span> &lt;span class="n">cs&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">DELEGATE&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cs&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">CharsetDecoder&lt;/span> &lt;span class="nf">newDecoder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">DELEGATE&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newDecoder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">CharsetEncoder&lt;/span> &lt;span class="nf">newEncoder&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">DELEGATE&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">newEncoder&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为字符集在 JDK 中是以命名服务实现的，所以我们同时还要设置新字符集的规则名称（&lt;span lang="en">Canonical Name&lt;/span>）和别名（&lt;span lang="en">Aliases&lt;/span>），这里将规则名称设置为 &lt;em>9527&lt;/em>，将别名集合设置为 &lt;em>mew-9527&lt;/em> 和 &lt;em>mew&lt;/em>。规则名称在命名空间中唯一确定一个字符集，别名提供了额外的查询方式。&lt;/p>
&lt;p>第 15 - 25 行是 &lt;em>Charset&lt;/em> 的子类需要实现的 3 个方法，包括编码器和解码器，这里直接将逻辑转发给 UTF-8 的实现，真实的情况会更加复杂，因为我们需要自行实现编解码器，并做真正的底层字节处理。&lt;/p>
&lt;h3 id="定义-charsetprovider">定义 CharsetProvider&lt;/h3>
&lt;p>接下来是实现 &lt;em>CharsetProvider&lt;/em>，但通常我们只需要扩展 &lt;em>AbstractCharsetProvider&lt;/em> 即可，&lt;em>AbstractCharsetProvider&lt;/em> 提供了基本的字符集管理实现，包括名称管理、别名管理、缓存。&lt;/p>
&lt;p>构造 &lt;em>AbstractCharsetProvider&lt;/em> 时还可以提供一个名为 &lt;em>pkgPrefixName&lt;/em> 的参数，它用于指定该字符集提供者所管理的字符集从哪一个包中查找实现类，默认包前缀为 &lt;em>sun.nio.cs&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">protected&lt;/span> &lt;span class="nf">AbstractCharsetProvider&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">packagePrefix&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;sun.nio.cs&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="nf">AbstractCharsetProvider&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">pkgPrefixName&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">packagePrefix&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pkgPrefixName&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下代码展示了名为 &lt;em>_9527CharsetProvider&lt;/em> 的实现，并指定在 &lt;em>zhix.encoding.spi&lt;/em> 的包中查询字符集。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">zhix.encoding.spi&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">_9527CharsetProvider&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">AbstractCharsetProvider&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">CANONICAL_NAME&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;9527&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">ALIASES&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">{&lt;/span>&lt;span class="s">&amp;#34;mew&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;mew-9527&amp;#34;&lt;/span>&lt;span class="o">};&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">initialized&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">_9527CharsetProvider&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">super&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;zhix.encoding.spi&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">initialized&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">super&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">init&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;{} initialized.&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">getClass&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">charset&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;mew&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">_9527Charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSimpleName&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="n">ALIASES&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>
&lt;span class="s">&amp;#34;Register charset {} with class {}.&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">CANONICAL_NAME&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">_9527Charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">initialized&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第 16 行的 init 方法会在查询 SPI 字符集时被调用，外部的逻辑可能会多次调用该方法，因此需要开发者自己来保证只初始化一次，比如这里用第 9 行定义的 &lt;em>initialized&lt;/em> 变量来控制。&lt;/p>
&lt;p>第 23 行的 &lt;em>charset&lt;/em> 方法由基类 &lt;em>AbstractCharsetProvider&lt;/em> 提供，用于注册字符集的元信息描述：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="cm">/* Declare support for the given charset
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">charset&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">className&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">aliases&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classMap&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">className&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">aliases&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span>
&lt;span class="n">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">aliasMap&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">aliases&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">],&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">aliasNameMap&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">aliases&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">cache&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">clear&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>AbstractCharsetProvider&lt;/em> 根据参数的名称和别名，为字符集建立查询数据结构，在查询时若有匹配的字符集描述，则根据上文提到的 &lt;em>pkgPrefixName&lt;/em> + 类名，通过反射创建 &lt;em>Charset&lt;/em> 的实例，完成 &lt;em>Charset&lt;/em> 的查询并初始化。&lt;/p>
&lt;p>所有的 &lt;em>Charset&lt;/em> 初始化都是惰性的，并且 &lt;em>AbstractCharsetProvider&lt;/em> 维护了一个缓存来避免重复初始化。因此最佳实践是在应用程序里只使用一种类型的 &lt;em>Charset&lt;/em>。&lt;/p>
&lt;h3 id="配置-_9527charsetprovider">配置 _9527CharsetProvider&lt;/h3>
&lt;p>在项目的 &lt;em>resources/META-INF/services&lt;/em> 目录下新建文本文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">java.nio.charset.spi.CharsetProvider
&lt;/code>&lt;/pre>&lt;/div>&lt;p>写入一个内容为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">zhix.encoding.spi._9527CharsetProvider
&lt;/code>&lt;/pre>&lt;/div>&lt;p>的新行。&lt;/p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/configure-spi-in-meta-inf-directory.png"
alt="配置 _9527CharsetProvider"/>&lt;figcaption>
&lt;p>配置 _9527CharsetProvider&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="单元测试">单元测试&lt;/h3>
&lt;p>在 &lt;em>test/resources&lt;/em> 目录下创建单元测试类 &lt;em>_9527CharsetProviderTest&lt;/em>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">zhix.encoding&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.nio.charset.Charset&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.nio.charset.StandardCharsets&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">lombok.extern.slf4j.Slf4j&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.junit.Assert&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.junit.Before&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.junit.Test&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@SuppressWarnings&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;InjectedReferences&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Slf4j&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">_9527CharsetProviderTest&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">text&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;我能吞下玻璃而不伤身体&amp;#34;&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="n">Charset&lt;/span> &lt;span class="n">charset&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="nd">@Before&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setUp&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 触发 SPI 加载
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">charset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">forName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;9527&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 测试编解码结果一致
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Test&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testEncodingAndDecoding&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Charset name = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">name&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Charset displayName = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">displayName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Charset aliases = {}&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">aliases&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">assertEquals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">charset&lt;/span>&lt;span class="o">)));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 测试 _9527 和 UTF-8 一致
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Test&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testEncodingCompareToUTF8&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Charset&lt;/span> &lt;span class="n">utf8&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StandardCharsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">UTF_8&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">utf8Bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">utf8&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">_9527Bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">charset&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">assertArrayEquals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">utf8Bytes&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">_9527Bytes&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="c1">// 测试使用别名查询 Charset
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nd">@Test&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">testEncodingAndDecodingWithAlias&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">charset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">forName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;mew&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Assert&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">assertEquals&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">charset&lt;/span>&lt;span class="o">)));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行单元测试的结果如下：&lt;/p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/wzhix/image-hosting/images/20.3.16-unit-test-result-of-_9527-charset-provider.png"
alt="_9527CharsetProvider 单元测试结果"/>&lt;figcaption>
&lt;p>_9527CharsetProvider 单元测试结果&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>可以看到我们可以通过 &lt;code>Charset.forName(&amp;quot;9527&amp;quot;)&lt;/code> 的方式获得我们自己定义的 &lt;em>Charset&lt;/em> 实例，且实例的类型就是 &lt;em>_9527Charset&lt;/em>。&lt;/p>
&lt;h2 id="spi-的延伸讨论">SPI 的延伸讨论&lt;/h2>
&lt;p>SPI 使用延迟加载，会扫描整个类路径下的 &lt;em>META-INF/services&lt;/em> 目录，所有配置的实现类的无参构造方法都会被调用并实例化，也就是一次访问，所有候选类都会被加载。如果实际场景不需要使用所有的实现类，这些类就会白白占用 JVM 内存，其次如果实现类是一个重型类的话，更会造成严重的内存浪费。&lt;/p>
&lt;p>另外一个缺陷是，你只能通过 &lt;em>load&lt;/em> 方法返回的迭代器来迭代访问实现类，这是一种相当底层的编程接口，意味着你无法灵活地根据参数不同获取某个的实现类。如果要实际使用方便，一种可能的最佳的实现是：封装 load 方法，根据传入的参数控制返回的实现类的查找逻辑，并且设置一个类变量缓存查找的结果。&lt;/p>
&lt;h3 id="spi-与-api">SPI 与 API&lt;/h3>
&lt;p>SPI 和 API 本质上都是 &lt;span lang="en">Specification&lt;/span> 和 &lt;span lang="en">Implementation&lt;/span> 的不同表现形式，区别在于：&lt;/p>
&lt;ul>
&lt;li>API 的使用者不关心规范的具体实现细节，只关心 API 的使用规范，开发者通过组织 API 提供的功能来实现目标。&lt;/li>
&lt;li>SPI 的开发者按照规范实现接口，通过满足规范的规约来实现目标。&lt;/li>
&lt;/ul>
&lt;p>简单来说就是，对于一套编程规范，如果你使用规范提供的功能来编程，规范对你来说就是 API，如果你通过编程来满足规范的所有要求，则规范对你来说就是 SPI。&lt;/p>
&lt;p>也可以参考 StackOverflow 上的 &lt;a href="https://stackoverflow.com/a/2956803">这个回答&lt;/a>。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>JDK 在 6.0 的时候发布了 SPI 机制，解决了实现类在运行时如何确定的问题，有利于应用程序的扩展，对 Spring 等框架也产生了重要影响，现如今看来，它的实现方式比较底层，一般需要在外层封装更抽象的控制逻辑来使用，同样 SPI 也存在内存占用的缺陷，&lt;a href="https://cloud.tencent.com/developer/article/1121665">静态绑定&lt;/a>&lt;sup id="fnref:4">&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 机制可以解决这个问题。&lt;/p>
&lt;p>通过 SPI，我们可以实现一些 JDK 内置功能的模块插入，比如自行实现 &lt;em>Charset&lt;/em>。以上字符集加载的完整代码可以在 GitHub 项目 &lt;a href="https://github.com/wzhix/9527-charset-encoding">9527-charset-encoding&lt;/a> 中查看，如果有任何问题和建议可以在项目里提交 Issue 给我。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>JAR 文件的规范和 &lt;em>META-INF&lt;/em> 目录的详细介绍参见 Oracle 的 &lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html">Java SE Documentation&lt;/a>&amp;#160;&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>Baeldung 中关于 &lt;a href="https://www.baeldung.com/java-spi#3-service-provider">&lt;em>Service Provider&lt;/em>&lt;/a> 的介绍&amp;#160;&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>SPI 的详细配置规范参见 Oracle 的 &lt;a href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html">The Java™ Tutorials&lt;/a> 教程&amp;#160;&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>静态绑定的典型应用是 &lt;a href="http://www.slf4j.org/">Slf4J&lt;/a>&amp;#160;&lt;a href="https://zhix.co/posts/talking-spi-in-java/#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/series/java-%E6%A0%B8%E5%BF%83/">Java 核心</category><category domain="https://zhix.co/tags/java/">Java</category><category domain="https://zhix.co/tags/%E7%BC%96%E7%A8%8B/">编程</category><category domain="https://zhix.co/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category><category domain="https://zhix.co/tags/utf-8/">UTF-8</category><category domain="https://zhix.co/tags/unicode/">Unicode</category><category domain="https://zhix.co/tags/jdk/">JDK</category><category domain="https://zhix.co/tags/spi/">SPI</category><category domain="https://zhix.co/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集</category></item><item><title>用遗传算法解决规划问题（一）</title><link>https://zhix.co/posts/solving-planing-problem-by-genetic-algorithm/</link><guid isPermaLink="true">https://zhix.co/posts/solving-planing-problem-by-genetic-algorithm/</guid><pubDate>Sat, 15 Feb 2020 20:54:41 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;p>我的算法知识启蒙源自大学时期的「人工智能技术与运用」课程，这门课教授的第一个技术要点是「搜索问题」，由启发式搜索的概念展开，后续描述了各类算法实现，比如遗传算法、模拟退火，也包括各种实际问题的解决，比如迷宫寻路、七桥问题。工作之后的第一年，我在一家游戏公司担任服务端工程师，期间项目组正在制作一款 TPS 类型的坦克载具类 5v5 对战网游，类似于移动版的「坦克世界」，当时我需要解决的第一个比较棘手的问题是：如何为匹配服务器设计一个分配算法，使得双方 5 辆坦克的类型、战斗力、玩家战斗水平都尽量公平。&lt;/p>
&lt;h2 id="澡盆玩具生产问题">澡盆玩具生产问题&lt;/h2>
&lt;p>详细讨论上述匹配问题之前，先聊聊另一个更加简单的问题&lt;span>，&lt;/span>《&lt;span lang="en">Head First Data Analysis&lt;/span>》这本书的第三章描述了一个入门的规划问题：&lt;/p>
&lt;p>假设你是一家名为「浴盆宝」的公司的数据分析师，这家公司的业务是生产和销售澡盆玩具，主要的产品线有两个：橡皮鸭和橡皮鱼，其中每只橡皮鸭和橡皮鱼的利润分别是 5 美元和 4 美元，它们分别消耗 100 单位和 125 单位的橡胶成本，问如果想让产品在下个月上架销售，橡皮鸭的产量不高于 400 只，橡皮鱼的产量不高于 300 只、且成本不超过 50000 单位橡胶的情况下，怎样的生产组合能够使利润最大。&lt;/p>
&lt;p>上述参数转化为表格的描述如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">产品&lt;/th>
&lt;th style="text-align:center">最大产量&lt;/th>
&lt;th style="text-align:center">利润&lt;/th>
&lt;th style="text-align:center">单位成本&lt;/th>
&lt;th style="text-align:center">产量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Duck&lt;/td>
&lt;td style="text-align:center">400&lt;/td>
&lt;td style="text-align:center">$5&lt;/td>
&lt;td style="text-align:center">100&lt;/td>
&lt;td style="text-align:center">$N_d$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Fish&lt;/td>
&lt;td style="text-align:center">300&lt;/td>
&lt;td style="text-align:center">$4&lt;/td>
&lt;td style="text-align:center">125&lt;/td>
&lt;td style="text-align:center">$N_f$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>即产量满足约束&lt;/p>
&lt;p>$$
100N_d + 125N_f \leq 50000 \mid N_d \leq 400, N_f \leq 300
$$&lt;/p>
&lt;p>时，使得 $5N_d + 4N_f$ 最大。&lt;/p>
&lt;p>书中引入这个案例更多是为了介绍如何在 &lt;span lang="en">Microsoft Excel&lt;/span> 中操作以做规划求解，而如何通过解不等式方程得到最优解不在本文讨论范围之内。这里介绍这个基础的案例是为了讨论如何用遗传算法解该问题。&lt;/p>
&lt;h2 id="遗传算法">遗传算法&lt;/h2>
&lt;blockquote>
&lt;p>遗传算法（&lt;span lang="en">Genetic Algorithm (GA)&lt;/span> ）是计算数学中用于解决最优化的搜索算法，是进化算法的一种。进化算法最初是借鉴了进化生物学中的一些现象而发展起来的，这些现象包括遗传、突变、自然选择以及杂交等。&lt;/p>
&lt;p>遗传算法通常实现方式为一种计算机模拟。对于一个最优化问题，一定数量的候选解（称为个体）可抽象表示为染色体，使种群向更好的解进化。传统上，解用二进制表示（即 0 和 1 的串），但也可以用其他表示方法。进化从完全随机个体的种群开始，之后一代一代发生。在每一代中评价整个种群的适应度，从当前种群中随机地选择多个个体（基于它们的适应度），通过自然选择和突变产生新的生命种群，该种群在算法的下一次迭代中成为当前种群。&lt;/p>
&lt;/blockquote>
&lt;p>遗传算法以达尔文的进化论为理论提出以下结论：生物以种群（&lt;span lang="en">Population&lt;/span>）为单位做演化，种群由若干数量的个体组成，每个个体都有自己的基因（&lt;span lang="en">Gene&lt;/span>）序列，不同的基因序列表现不同的性状，因此具有不同的环境适应度（&lt;span lang="en">Fitness&lt;/span>），适应度高的个体更容易在自然选择中生存下来，将自己的基因序列遗传给下一代个体，两个个体之间会发生基因的交叉（&lt;span lang="en">Crossover&lt;/span>），即繁殖过程，单个个体的基因序列存在一定概率发生突变（&lt;span lang="en">Mutation&lt;/span>）而产生新的基因序列。&lt;/p>
&lt;p>所谓的基因序列，就是将解空间中的解进行编码，使得解空间的每一个解都有唯一的一组基因对应。比较通用的编码方式就是 0-1 二进制串，若某个问题的解是可枚举的，且总共存在 $M$ 种不同的可能解，那么可以选择 $2n$ 中第一个超过 $M$ 的 $n$ 的自然数作为基因的编码长度，比如解有 960 中可能时用 10 位二进制串编码基因，解有 60000 中可能时用 16 位二进制串编码基因，依次类推。根据该结论，随着种群一代一代演化，适应度低的个体会被逐渐淘汰，保留下来的个体的基因序列都倾向于有更高的适应度，经过若干轮处理后，种群朝着整体适应度更高的方向发展，适应度最高的个体的基因序列便是我们需要的解。&lt;/p>
&lt;p>在实践中我们发现，演化的方向可能是贪婪的，因此可能出现种群整体朝着一个次优的方向演化并在某一代收敛，即新产生的基因的适应度不再高于种群整体的适应度，以至于之后的演化不在产生更好的解。想象一个求极大值的函数的函数图像在给定定义域里存在两个波峰，它们的值一高一低，贪婪的演化可能导致基因序列在演化开始后逐渐趋近于低波峰附近的解且无法跳出。引入突变则使得即使是较高适应度的基因序列仍有一定概率突变成更好的或者更差的基因序列，从而跳出当前的解范围。从生物学的角度来说就是，遗传物质的复制过程中存在一定概率出现差错，进而为个体带来全新的基因序列，这种差错是完全随机的，带来的优劣也是因环境而异。&lt;/p>
&lt;blockquote>
&lt;p>突变通常会导致细胞运作不正常或死亡，甚至可以在较高等生物中引发癌症。但同时，突变也被视为演化的「推动力」：不理想的突变会经天择过程被淘汰，而对物种有利的突变则会被累积下去。&lt;/p>
&lt;/blockquote>
&lt;p>通用的遗传算法一般会有以下几个控制参数：基因长度、种群大小、突变率、演化次数、随机数种子和适应度函数。&lt;/p>
&lt;dl>
&lt;dt>基因长度&lt;/dt>
&lt;dd>正如之前描述的，依据解空间的大小可以确定基因长度，比如对于 10 位基因长度、解空间大小为 960 的问题来说，一个可能的解为 0100101101 (301)。&lt;/dd>
&lt;dt>种群大小&lt;/dt>
&lt;dd>计算机依据种群为单位批量计算，种群大小即计算机一次处理的样本大小，设置过大的种群大小会消耗更多的计算资源，设置过小则会导致进化缓慢，甚至可能出现演化结束后依旧无法找到最优解。最佳的大小值可能因问题和计算力而异。&lt;/dd>
&lt;dt>突变（概）率&lt;/dt>
&lt;dd>突变的产生是概率性的，表现在算法中就是，每一个个体在演化过程中都有一定概率使得自己基因序列的某一位或者某几位发生比特逆转。设置过小的突变率，比如 0，即不发生突变，会出现上一节描述的次优解陷阱，而过高的突变率会使得算法退化为无目的的随机搜索，一般来说 5% ~ 10% 的突变率就能够适应大部分问题。&lt;/dd>
&lt;dt>演化次数&lt;/dt>
&lt;dd>遗传算法本质上是一个有限步骤的算法，我们必须决定何时结束算法的循环，通常会设置经过多少代的演化后结束，或是直到种群中的某个个体适应度超过给定值后结束。无论是哪一种，这个参数是用来表示何时算法得以中止。同样，过快的终止条件可能导致尚未搜索出最优解的情况下中止，过慢的中止条件则导致后期已经收敛的种群演化效率低下。&lt;/dd>
&lt;dt>随机数种子&lt;/dt>
&lt;dd>用于生成初始种群的基因序列，相同的随机数种子应当每次都生成相同的初始种群。可随意设置，一般设置为当前的时间戳。&lt;/dd>
&lt;dt>适应度函数&lt;/dt>
&lt;dd>适应度函数模拟了环境的选择，决定了某一个基因序列对应的解的优劣。这里的优劣完全取决于适应度函数的定义，对于同一个问题，不同的适应度函数可能导致最终产生完全不同的种群，这与实际的生物演化是相符的，就好比橘树栽在淮南就是橘，而栽在淮北却变成了枳，或是亚洲象和非洲象在性状上的差异。无论如何，适应度函数的定义域等于解空间。&lt;/dd>
&lt;/dl>
&lt;p>通常来说，我们面对的问题还会设置一些限制条件，比如生产问题中消耗量不能高于供给量，或是匹配问题中的玩家平均等级差不超过给定范围等。若最终演化后种群中的个体的基因序列对应的解违反了这些限制条件，则意味着演化出现了无用的解。因此有必要指定一些致死基因（&lt;span lang="en">Lethal Gene&lt;/span>）来优化演化算法，所谓的致死基因就是那些对应的解违反了限制条件的基因序列，若演化得到的新基因序列包含致死基因，则设置该基因序列的适应度为 0，因为适应度为 0 的基因序列永远无法通过自然选择（随机轮盘）将自身遗传到下一代，用伪代码表示就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-coffeescript" data-lang="coffeescript">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">gene&lt;/span> &lt;span class="o">is&lt;/span> &lt;span class="nx">lethal&lt;/span> &lt;span class="nx">gene&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nv">fitness = &lt;/span>&lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nv">fitness = &lt;/span>&lt;span class="nx">Fitness&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>遗传算法是 &lt;a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%BC%96%E7%A8%8B">遗传编程&lt;/a> 的一个实现，这类编程范式的本质在于告诉计算机需要完成什么而不是如何完成，通过特定的策略去搜索解空间中的解并逐步收敛，最终找到最优解。&lt;/p>
&lt;h2 id="用遗传算法解决澡盆玩具问题">用遗传算法解决澡盆玩具问题&lt;/h2>
&lt;p>以上一节中的澡盆玩具生产问题为例，我们用 $x$ 代表最终生产的橡皮鸭数量，$y$ 代表最终生产的橡皮鱼数量，则任意合法的、不包含致死基因 $x$ 和 $y$ 的组合都是一个解，则问题的本质变成了：我们需要在有限的步骤内找到一组 $(x, y)$ 使得 $\text{Fitness}(x, y)$ 最大。&lt;/p>
&lt;h3 id="基因定义">基因定义&lt;/h3>
&lt;p>由于 $x$ 不超过 400，$y$ 不超过 300，与 400 和 300 最接近的 $2n$ 为 512 即 $n$ = 9，因此可以设置基因序列的长度为 9 + 9 = 18 位，解的个数应当低于 2&lt;sup>18&lt;/sup>=262144 个，但实际有效的解会低于这个数字，因为这个数字包括了 $y\gt400$ 或 $y\gt300$ 的情况。想象一个长度为 18 的比特串，索引 0-8 的位置分配给 $x$，索引 9-17 的位置分配给 $y$，这个比特串就是这个问题的基因序列的编码方式。&lt;/p>
&lt;h3 id="参数设置">参数设置&lt;/h3>
&lt;p>我们已经确定基因序列的长度为 18，这里我们使用如下的参数配置来初始化算法。实际上，寻找一个正确而高效的参数来配置遗传算法可能需要多次调试：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">参数名称&lt;/th>
&lt;th style="text-align:center">参数值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">基因长度&lt;/td>
&lt;td style="text-align:center">18 位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">种群大小&lt;/td>
&lt;td style="text-align:center">200 个&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">突变率&lt;/td>
&lt;td style="text-align:center">7.5%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">随机数种子&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">演化次数&lt;/td>
&lt;td style="text-align:center">200 代&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>设置适应度函数为：&lt;/p>
&lt;p>$$
F =
\begin{cases}
5x + 4y, &amp;amp; \text{if $x \leq 400 \land y \leq 300 \land 100x + 125y \leq 50000$} \\&lt;br>
0, &amp;amp; \text{otherwise}
\end{cases}
$$&lt;/p>
&lt;h3 id="自然选择">自然选择&lt;/h3>
&lt;p>下面开始真正的算法迭代过程，首先进行的是自然选择步骤，为了简便起见，我们假设种群只包含 4 个个体，初始种群的个体基因序列是随机生成的，我们以 0 为随机数种子生成初始种群，假定生成的 4 个个体 $a \sim d$ 的基因序列如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>个体名称&lt;/th>
&lt;th>基因序列&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>𝑎&lt;/td>
&lt;td>&lt;code>001111000011001000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>𝑏&lt;/td>
&lt;td>&lt;code>100101100011001000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>𝑐&lt;/td>
&lt;td>&lt;code>000111100001001011&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>𝑑&lt;/td>
&lt;td>&lt;code>001110100010000010&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>通过拆分二进制串可以计算得到每个基因序列对应的 $x$、$y$ 和适应度：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">个体名称&lt;/th>
&lt;th style="text-align:left">基因序列&lt;/th>
&lt;th style="text-align:right">𝑥 和 𝑦 值&lt;/th>
&lt;th style="text-align:right">适应度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">𝑎&lt;/td>
&lt;td style="text-align:left">&lt;code>001111000011001000&lt;/code>&lt;/td>
&lt;td style="text-align:right">120, 200&lt;/td>
&lt;td style="text-align:right">1400&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">𝑏&lt;/td>
&lt;td style="text-align:left">&lt;code>100101100011001000&lt;/code>&lt;/td>
&lt;td style="text-align:right">300, 200&lt;/td>
&lt;td style="text-align:right">2300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">𝑐&lt;/td>
&lt;td style="text-align:left">&lt;code>000111100001001011&lt;/code>&lt;/td>
&lt;td style="text-align:right">60, 75&lt;/td>
&lt;td style="text-align:right">600&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">𝑑&lt;/td>
&lt;td style="text-align:left">&lt;code>001110100010000010&lt;/code>&lt;/td>
&lt;td style="text-align:right">116, 130&lt;/td>
&lt;td style="text-align:right">1100&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在遗传算法的迭代过程中，种群的个体数量始终恒定不变，n 个个体的种群演化至下一代仍有 n 个个体，自然选择的过程就是通过某种选择策略，从上一代的 n 个个体选择 n 次，组建出下一代的 n 个个体，通常的选择策略便是依据个体适应度大小的加权随机采样，想象将 $a \sim d$ 依据适应度绘制一个饼图：&lt;/p>
&lt;p>加权随机的意思是在该圆中随机某一点，该点对应 $a \sim d$ 哪一个的区域，就选择哪一个个体，重复 4 次。加权随机的具体实现算法在此不赘述，不管怎样，适应度越高的个体，在饼图中占据的区域越大，随机生成的点落在该个体区域的概率也越高，反之，低适应度的个体更加不容易被选中，对应于自然界的「适者生存」。假设经过一轮自然选择后的种群为 $\{b_1, a, b_2, d\}$：意味着在下一轮的 4 次选择中，$b$ 在第 1 次和第 3 次被命中，第 2 次命中了 𝑎，第 4 次命中了 $d$，而 $c$ 因为适应度最低不幸没有被命中。这是一个很大可能的结果，因为 $c$ 的命中概率为 11.1% 而远低于 $b$ 的 42.6%，此时的种群基因序列如下&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">个体（选择前）&lt;/th>
&lt;th style="text-align:right">适应度（选择前）&lt;/th>
&lt;th style="text-align:left">个体（选择后）&lt;/th>
&lt;th style="text-align:right">适应度（选择后）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">$a$&lt;/td>
&lt;td style="text-align:right">1400&lt;/td>
&lt;td style="text-align:left">$b_1$&lt;/td>
&lt;td style="text-align:right">2300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$b$&lt;/td>
&lt;td style="text-align:right">2300&lt;/td>
&lt;td style="text-align:left">$a$&lt;/td>
&lt;td style="text-align:right">1400&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$c$&lt;/td>
&lt;td style="text-align:right">60&lt;/td>
&lt;td style="text-align:left">$b_2$&lt;/td>
&lt;td style="text-align:right">2300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$d$&lt;/td>
&lt;td style="text-align:right">1100&lt;/td>
&lt;td style="text-align:left">$d$&lt;/td>
&lt;td style="text-align:right">1100&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看出选择前种群的平均适应度为 1350，而选择后为 1775，即经过一轮自然选择，种群中的个体普遍比上一代个体具有更高的适应度。同时，带有致死基因的个体因为其适应度为 0 而永远不会被自然选择命中，这保证了我们能够及早的在搜索结果中排除那些不满足限制条件的解。&lt;/p>
&lt;h3 id="基因交叉">基因交叉&lt;/h3>
&lt;p>演化迭代的第二步是基因交叉，基因交叉发生与两两个体之间，指的是两个个体间的基因序列在随机某个位置之后的子序列发生交换，假设对于上一节经过自然选择之后的种群 $\{b_1, a, b_2, d\}$ 在基因位置 14 之后的子序列进行基因交叉，即 $b_1$ 与 $a$ 交叉，$b_2$ 与 $d$ 交叉，则如下表格描述了经过交叉后的种群的基因序列和对应的适应度：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">个体&lt;/th>
&lt;th style="text-align:left">交叉前基因序列后 9 位&lt;/th>
&lt;th style="text-align:left">交叉后基因序列后 9 位&lt;/th>
&lt;th style="text-align:right">新 $x$ 和 $y$&lt;/th>
&lt;th style="text-align:right">新适应度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">$b_1$&lt;/td>
&lt;td style="text-align:left">&lt;code>011001000&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>011001000&lt;/code>&lt;/td>
&lt;td style="text-align:right">300, 200&lt;/td>
&lt;td style="text-align:right">2300&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$a$&lt;/td>
&lt;td style="text-align:left">&lt;code>011001000&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>011001000&lt;/code>&lt;/td>
&lt;td style="text-align:right">120, 200&lt;/td>
&lt;td style="text-align:right">1400&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$b_2$&lt;/td>
&lt;td style="text-align:left">&lt;code>011001000&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>011000010&lt;/code>&lt;/td>
&lt;td style="text-align:right">300, 194&lt;/td>
&lt;td style="text-align:right">2276&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">$d$&lt;/td>
&lt;td style="text-align:left">&lt;code>010000010&lt;/code>&lt;/td>
&lt;td style="text-align:left">&lt;code>010001100&lt;/code>&lt;/td>
&lt;td style="text-align:right">116, 140&lt;/td>
&lt;td style="text-align:right">1140&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看出交叉前种群的平均适应度为 1775，而交叉后为 1779，即经过一轮基因交叉，种群中的个体的适应度比上一代个体略有上升，若选择另一位置的字序列交叉，则可能出现更坏的情况。如果说自然选择是已有基因序列的择优筛选，本质上并没有为种群引入新的基因序列，而从这一步开始，种群内的个体产生了新的基因序列。&lt;/p>
&lt;h3 id="基因变异">基因变异&lt;/h3>
&lt;p>演化迭代的第三步是基因变异，基因变异发生在单个个体间，每个个体在每一轮迭代中都有一定概率出现遗传物质的复制错误，该行为模拟了生物 DNA 的转录错误，表现在算法中就是比特串某一位置的比特值发生反转。与基因交叉类似，变异可能产生原本种群内不存在基因，这可能改变种群整体的进化方向以避免之前讨论过的次有解陷阱。&lt;/p>
&lt;p>假设经过上一步交叉后的种群里，只有个体 $b_1$ 发生了基因突变，且突变的位置为 4，则 $b_i$ 突变后的基因即从 1001..0..1100011001000 变异为 100..1..01100011001000。&lt;/p>
&lt;h3 id="种群更替与搜索结果">种群更替与搜索结果&lt;/h3>
&lt;p>在种群完成「自然选择」、「基因交叉」和「基因突变」后，种群便完成了一次代际的更替，一般来说，新的种群会比上一代种群更加适合生存。如果选择了合适的参数，算法能够在中止前完成搜索的解收敛。&lt;/p>
&lt;p>我在我的机器上按照上述参数实现了一版算法，运行后最终种群在第 4 代便完成了解的收敛，最终算法给出的适应度最高的基因为 110010000001010000，即 $x$=400,$y$=80 时，利润最高，达到 2320 美元。&lt;/p></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/tags/%E7%AE%97%E6%B3%95/">算法</category><category domain="https://zhix.co/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</category><category domain="https://zhix.co/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">遗传算法</category><category domain="https://zhix.co/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/">启发式搜索</category></item><item><title>谈谈 Spring Boot 的自动配置</title><link>https://zhix.co/posts/spring-factories-and-jdk-spi-mechanism/</link><guid isPermaLink="true">https://zhix.co/posts/spring-factories-and-jdk-spi-mechanism/</guid><pubDate>Sat, 15 Feb 2020 19:05:32 +0800</pubDate><author>zhixuan@zhix.co (zhix)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;p>Spring Boot 的 EnableAutoConfiguration 注解提供了自动发现和加载配置的能力，赋予了应用程序强大的可扩展性，该特性依赖于 SpringFactoryLoader 在 CLASSPATH 中寻找并解析 META-INF 目录下的 spring.factories 文件，这种做法延伸于 JDK 6.0 引入的 &lt;span lang="en">Service Provider Interface&lt;/span> 机制，该机制的目的则是简化可扩展应用程序的设计和代码解耦。&lt;/p>
&lt;h2 id="可扩展应用程序">可扩展应用程序&lt;/h2>
&lt;p>&lt;a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html">可扩展的应用程序&lt;/a> 即在不修改源代码的情况下，原程序可通过某种方式的处理以实现功能的伸缩和特性的增减，所谓的可扩展通常表现为支持插件或者模块子系统。因此，这类应用程序的使用者除了最终用户以外，还有第三方开发商。对于 Java 程序而言，这样的可扩展通常表现为「提供对外的 API 调用」、「在 CLASSPATH 引入 JAR 依赖」、「在 &lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html">META-INF&lt;/a> 目录下做配置」或者「在特定目录下放入插件文件」等方式，各个表现方式和它们对应的示例如下表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">表现形式&lt;/th>
&lt;th style="text-align:left">举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">应用程序提供 API 调用&lt;/td>
&lt;td style="text-align:left">Netty 对特定 Channel 的 Pipeline 处理&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">CLASSPATH 引入 JAR 依赖&lt;/td>
&lt;td style="text-align:left">Spring Boot 配置自动发现&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">META-INF 目录下配置文件&lt;/td>
&lt;td style="text-align:left">JDK 的 SPI 机制、Spring Factory 机制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">特定目录下放入插件文件&lt;/td>
&lt;td style="text-align:left">IntelliJ IDEA 插件管理、游戏 MOD 管理&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以游戏中的 MOD 管理为例，游戏团队并不能在编译期确定所有 MOD 列表，具体的 MOD 由第三方开发者在运行时实现。对于游戏团队来说，需要制定一个统一的 MOD 接入规范，并在程序启动时，以配置文件或者自动扫描的方式发现并初始化所有 MOD，而第三方开发者通过开发新的 MOD 来扩展原游戏的功能或改变原游戏的行为，因而那些支持 MOD 的游戏通常会表现出极强的可扩展性。&lt;/p>
&lt;p>可以看出，设计可扩展的应用程序的核心思想是解耦，即服务调用方不关心实现方的具体实现，也不用在代码中引入任何实现方的具体类。&lt;/p>
&lt;h3 id="meta-inf-目录">META-INF 目录&lt;/h3>
&lt;p>META-INF 从字面意义上理解就是元信息，对于 META-INF 目录，Oracle 的 &lt;a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html">文档&lt;/a> 有如下的描述：&lt;/p>
&lt;blockquote>
&lt;p lang="en">In many cases, JAR files are not just simple archives of java classes files and/or resources. They are used as building blocks for applications and extensions. The META-INF directory, if it exists, is used to store package and extension configuration data, including security, versioning, extension and services.&lt;/p>
&lt;p>以配置文件或者自动扫描的方式发现并初始化所有 MOD，而第三方开发者通过开发新的 MOD 来扩展原游戏的功能或改变原游戏的行为，因而那些支持 MOD 的游戏通常会表现出极强的可扩展性。&lt;/p>
&lt;/blockquote>
&lt;p>即虽然 JAR 文件在内容上打包了 CLASS 和资源文件，但随着 Java 技术的发展，JAR 也逐渐成为了应用程序的扩展模块，而配置数据正是放在该目录下。所以 META-INF 目录本质上来说是一个对 JAR 文件有特殊意义的目录，里面存放了一些特殊的数据，比如扩展配置、签名数据等。&lt;/p>
&lt;p>META-INF 目录的读取在很多框架中都有涉及，比如 Spring Framework、Dubbo、携程的 Apollo。我们也可以在该目录下设置自己的元信息格式，甚至都不强制一定在 META-INF 目录下，只是一般约定会将元信息统一放在一个文件夹下，实际上 JAR 文件中的资源都可以通过如下方式读取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">URL&lt;/span> &lt;span class="n">resourceUrl&lt;/span>
&lt;span class="o">=&lt;/span> &lt;span class="n">ClassLoader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSystemClassLoader&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;&amp;lt;resource-name&amp;gt;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">URL&lt;/span> &lt;span class="n">metaInfResourceUrl&lt;/span>
&lt;span class="o">=&lt;/span> &lt;span class="n">ClassLoader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSystemClassLoader&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getResource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;META-INF/&amp;lt;resource-name&amp;gt;&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java-中的-spi-机制">Java 中的 SPI 机制&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Service_provider_interface">Service Provider Interface&lt;/a> 在 JDK 6.0 之后引入，旨在简化可扩展应用程序的设计，通过 SPI 机制，开发者可以更为方便地为应用程序创建可替换的模组。SPI 的本质是自动发现和装载特定接口的实现类，它解决了接口的「运行时实现」和「运行时实现的自动发现」问题。&lt;/p>
&lt;h2 id="service-loader">Service Loader&lt;/h2>
&lt;p>SPI 的核心是 ServiceLoader 类，它被声明为 final 的，提供一个惰性加载的 load 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">java.util&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ServiceLoader&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">Iterable&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ServiceLoader&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">load&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">service&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ClassLoader&lt;/span> &lt;span class="n">loader&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，service 参数定义了需要被加载的接口或者抽象类的 Class 对象，loader 参数则指定了加载使用的加载器。&lt;/p>
&lt;h3 id="jdk-中-spi-的应用">JDK 中 SPI 的应用&lt;/h3>
&lt;p>JDK 的很多内置模块和应用都使用了 SPI 机制，比如：&lt;/p>
&lt;dl>
&lt;dt>&lt;code>java.sql.Driver&lt;/code>&lt;/dt>
&lt;dd>JDBC API 在 4.0 版本之后使用 SPI 加载数据库驱动程序（4.0 版本之前使用 Class.forName(&amp;quot;&lt;driver-fqn>&amp;quot;)）。&lt;/dd>
&lt;dt>&lt;code>java.nio.charset.CharsetProvider&lt;/code>&lt;/dt>
&lt;dd>JDK 中的字符集使用 SPI 加载所有 CharsetProvider 的实现类。&lt;/dd>
&lt;/dl>
&lt;p>一些第三方程序和框架也大量使用：&lt;/p>
&lt;dl>
&lt;dt>&lt;code>org.slf4j.ILoggerFactory&lt;/code>&lt;/dt>
&lt;dd>SLF4J 中定义的日志器工厂类，使用 SPI 在运行时发现可用的实现。&lt;/dd>
&lt;/dl>
&lt;p>除此之外，在货币、本地化、日期时间的处理也是基于 SPI 实现，相应的，我们也可以使用 SPI 对 JDK 扩展我们自己的本地化或日期时间实现。&lt;/p>
&lt;h3 id="spi-约定">SPI 约定&lt;/h3>
&lt;p>根据 ServiceLoader的 JavaDoc 文档描述，若要使用 SPI 对应用程序进行扩展，需要遵循以下几个约定：&lt;/p>
&lt;ol>
&lt;li>在应用程序 CLASSPATH 下存在 META-INF/services 目录；&lt;/li>
&lt;li>对每一个需要被实现的接口或抽象类，用其完全限定名为文件名称创建文本文件，文件的编码格式必须为 UTF-8；&lt;/li>
&lt;li>文件每一行的内容为实现类的完全限定名。&lt;/li>
&lt;/ol>
&lt;p>以 JDBC 中的驱动程序 java.sql.Driver 为例，若我们打算在 JDK 注册自己的 JDBC 驱动实现，我们需要在 META-INF/services 目录下创建名为 java.sql.Driver 的文本文件，并确保编码格式为 UTF-8，并在文件中写入一行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">resources/
└── META-INF/
└── services/
└── java.sql.Driver
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并在文件 java.sql.Driver 中写入如下一行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">your&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">package&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">DriverImpl&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>至此，我们可以在应用程序中安全地调用如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">ServiceLoader&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Driver&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">driverServiceSSSSSSSSSiverS&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="实战基于-spi-的字符集扩展">实战基于 SPI 的字符集扩展&lt;/h3>
&lt;p>下面以对 java.nio.charset.Charset 的字符集扩展来实践 SPI 在日常开发中的使用：假设你设计了下一代的 UTF-8 字符编解码实现版本，并为该实现版本取名为 UTF-8-NG，你需要赶在下一版 JDK 公布之前，将这一版本接入到自己的应用程序中，并保证在你的应用程序 API 分发后，其他开发人员可以使用如下代码消费你的 UTF-8 实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.nio.Charset&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">Charset&lt;/span> &lt;span class="n">yourCharsetImpl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Charset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">forName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;utf-8-ng&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在通常情况下，上述代码会因为找不到对应的字符集而抛出 java.nio.charset.UnsupportedCharsetException 异常。 在 JDK 中，对字符集的管理是通过 java.nio.charset.spi.CharsetProvider 进行，它的基本定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">CharsetProvider&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="c1">// 获得所有受该字符集提供者所管理的字符集集合的迭代器对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="n">Iterator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Charset&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">charsets&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">// 在该字符集提供者所管理的字符集集合根据名称查找字符集对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">public&lt;/span> &lt;span class="kd">abstract&lt;/span> &lt;span class="n">Charset&lt;/span> &lt;span class="nf">charsetForName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">charsetName&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个典型的 SPI 接口，不同的 JDK vendor 有不同的实现，在截至本文完成时，Oracle JDK 中对应的实现是 sun.nio.cs.StandardCharsets，该类作为字符集管理的一个入口类，与之相伴的是其他由 Oracle 实现的具体字符集类。&lt;/p>
&lt;h2 id="spring-framework-中的-springfactories-文件">Spring Framework 中的 spring.factories 文件&lt;/h2>
&lt;h2 id="enableautoconfiguration-注解">EnableAutoConfiguration 注解&lt;/h2>
&lt;p>注解类 EnableAutoConfiguration 在 Spring Boot 中承担两个作用：「是否在被注解的包行启用配置自动发现机制」和「其完全限定名作为 META-INF/spring.factories 中的键来配置自动发现」。&lt;/p>
&lt;p>Spring Boot 的配置自动发现机制是以 Spring SPI 为基础实现的，Spring Boot 约定了自动发现的配置键在 META-INF/spring.factories 文件中的键为 org.springframwork.boot.autoconfigure.EnableAutoConfiguration，即启用自动发现的注解类 EnableAutoConfiguration 的完全限定名。&lt;/p></description><category domain="https://zhix.co/categories/%E6%8A%80%E6%9C%AF/">技术</category><category domain="https://zhix.co/tags/java/">Java</category><category domain="https://zhix.co/tags/%E7%BC%96%E7%A8%8B/">编程</category><category domain="https://zhix.co/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category><category domain="https://zhix.co/tags/spring-framework/">Spring Framework</category><category domain="https://zhix.co/tags/spring-boot/">Spring Boot</category><category domain="https://zhix.co/tags/jdk/">JDK</category></item></channel></rss>